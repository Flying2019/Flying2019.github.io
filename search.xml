<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Baltic Olympiad in Informatics 2016</title>
    <url>/2021/11/08/BOI2016/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Bosses</th>
<th align="center">Park</th>
<th align="center">Spiral</th>
<th align="center">Cities</th>
<th align="center">Maze</th>
<th align="center">Swap</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{red}{\texttt{-}}$</td>
<td align="center">$\color{red}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
</tr>
</tbody></table>
<h2 id="链接-题面链接-中文题面"><a href="#链接-题面链接-中文题面" class="headerlink" title="链接 题面链接 中文题面"></a><a href="https://cses.fi/87/list/">链接</a> <a href="https://www.cs.helsinki.fi/group/boi2016/day1_tasks.zip">题面链接</a> <a href="https://loj.ac/p?tagIds=212,37">中文题面</a></h2><span id="more"></span>

<h2 id="A-Bosses"><a href="#A-Bosses" class="headerlink" title="A. Bosses"></a>A. Bosses</h2><p>可以发现一个方案的总代价是所有点的深度之和。考虑枚举根，贪心的选一定让每个点往深度最小的点上挂。</p>
<p>所以连反边 bfs 一遍即可。复杂度 $O(n+m)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dis[N],n;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line">ll ans=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0</span>;</span><br><span class="line">    dis[s]=<span class="number">1</span>;queue&lt;<span class="keyword">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="keyword">if</span>(!dis[v]) dis[v]=dis[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!dis[i]) <span class="keyword">return</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=dis[i];</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">-1</span> || ans&gt;res) ans=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k,x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">        <span class="keyword">while</span>(k --&gt; <span class="number">0</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),g[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">bfs</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-Park"><a href="#B-Park" class="headerlink" title="B. Park"></a>B. Park</h2><p>定义两个圆之间的边为它们的距离（圆心距离减去半径之和）认为四个边界是四个特殊的圆。那么要使 $1,2$ 不连通，需要存在从 $1,2$ 的边界到其他边界只通过 $\leq 2r$ 的边的路径。换句话说就是把 $1,2$ 割开了。</p>
<p>其他同理。可以发现这就是最小瓶颈路，直接暴力枚举每对边界，暴力求瓶颈路，就可以做到 $O(1)$ 查询。</p>
<p>复杂度 $O(16n^2+n^2\log n+q)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> X,Y;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> x=<span class="number">0</span>,<span class="keyword">int</span> y=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">    node <span class="keyword">operator</span> +(node a)&#123;<span class="keyword">return</span> <span class="built_in">node</span>(x+a.x,y+a.y);&#125;</span><br><span class="line">    node <span class="keyword">operator</span> -(node a)&#123;<span class="keyword">return</span> <span class="built_in">node</span>(x-a.x,y-a.y);&#125;</span><br><span class="line">&#125;p[N];<span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(node a)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1ll</span>*a.x*a.x+<span class="number">1ll</span>*a.y*a.y);&#125;</span><br><span class="line"><span class="function">db <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">dis</span>(p[x]-p[y])-r[x]-r[y];&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">   ---</span></span><br><span class="line"><span class="comment">  |   |</span></span><br><span class="line"><span class="comment">1 |   | 3</span></span><br><span class="line"><span class="comment">  |   |</span></span><br><span class="line"><span class="comment">   ---</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">db <span class="title">dis_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="keyword">return</span> p[a].x-r[a];</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="keyword">return</span> p[a].y-r[a];</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="keyword">return</span> X-p[a].x-r[a];</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">4</span>) <span class="keyword">return</span> Y-p[a].y-r[a];</span><br><span class="line">    <span class="keyword">return</span> inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==f[x]?f[x]:(f[x]=<span class="built_in">find</span>(f[x]));&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">road</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;db w;</span><br><span class="line">&#125;e[N*N];<span class="keyword">int</span> et;</span><br><span class="line"><span class="function">db <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> r2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">4</span>;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=et;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="built_in">find</span>(e[i].x),y=<span class="built_in">find</span>(e[i].y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y) f[x]=y;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(r1)==<span class="built_in">find</span>(r2)) <span class="keyword">return</span> e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inf;</span><br><span class="line">&#125;</span><br><span class="line">db w[<span class="number">5</span>][<span class="number">5</span>],q[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X,&amp;Y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;p[i].x,&amp;p[i].y,&amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[++et]=&#123;i,j+n,<span class="built_in">dis_edge</span>(i,j)&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) e[++et]=&#123;i,j,<span class="built_in">dis</span>(i,j)&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+et+<span class="number">1</span>,[&amp;](road a,road b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) w[i][j]=w[j][i]=<span class="built_in">get_dis</span>(n+i,n+j);</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=4;i++,puts(&quot;&quot;))</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=4;j++) printf(&quot;%.6lf &quot;,w[i][j]);</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    4-4-3</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    1   3</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    1-2-2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    q[<span class="number">1</span>][<span class="number">2</span>]=q[<span class="number">2</span>][<span class="number">1</span>]=<span class="built_in">min</span>(&#123;w[<span class="number">2</span>][<span class="number">4</span>],w[<span class="number">2</span>][<span class="number">3</span>],w[<span class="number">2</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">    q[<span class="number">2</span>][<span class="number">3</span>]=q[<span class="number">3</span>][<span class="number">2</span>]=<span class="built_in">min</span>(&#123;w[<span class="number">3</span>][<span class="number">4</span>],w[<span class="number">3</span>][<span class="number">1</span>],w[<span class="number">3</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">    q[<span class="number">3</span>][<span class="number">4</span>]=q[<span class="number">4</span>][<span class="number">3</span>]=<span class="built_in">min</span>(&#123;w[<span class="number">4</span>][<span class="number">1</span>],w[<span class="number">4</span>][<span class="number">2</span>],w[<span class="number">4</span>][<span class="number">3</span>]&#125;);</span><br><span class="line">    q[<span class="number">4</span>][<span class="number">1</span>]=q[<span class="number">1</span>][<span class="number">4</span>]=<span class="built_in">min</span>(&#123;w[<span class="number">1</span>][<span class="number">2</span>],w[<span class="number">1</span>][<span class="number">3</span>],w[<span class="number">1</span>][<span class="number">4</span>]&#125;);</span><br><span class="line">    q[<span class="number">1</span>][<span class="number">3</span>]=q[<span class="number">3</span>][<span class="number">1</span>]=<span class="built_in">min</span>(&#123;w[<span class="number">1</span>][<span class="number">3</span>],w[<span class="number">2</span>][<span class="number">4</span>],w[<span class="number">1</span>][<span class="number">2</span>],w[<span class="number">3</span>][<span class="number">4</span>]&#125;);</span><br><span class="line">    q[<span class="number">2</span>][<span class="number">4</span>]=q[<span class="number">4</span>][<span class="number">2</span>]=<span class="built_in">min</span>(&#123;w[<span class="number">1</span>][<span class="number">3</span>],w[<span class="number">2</span>][<span class="number">4</span>],w[<span class="number">1</span>][<span class="number">4</span>],w[<span class="number">2</span>][<span class="number">3</span>]&#125;);</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=4;i++,puts(&quot;&quot;))</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=4;j++) printf(&quot;%.6lf &quot;,q[i][j]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) q[i][i]=inf;</span><br><span class="line">    <span class="keyword">while</span>(m --&gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r,e;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;e);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) <span class="keyword">if</span>(q[i][e]+eps&gt;=r*<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="D-Cities"><a href="#D-Cities" class="headerlink" title="D. Cities"></a>D. Cities</h2><p>最小斯坦纳树板子题。</p>
<p>用 dijkstra 增广，复杂度 $O(n2^k\log n+n3^k)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 100000000000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,<span class="keyword">int</span>&gt; P;</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt;q;</span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">2</span>],to[N&lt;&lt;<span class="number">2</span>],w[N&lt;&lt;<span class="number">2</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cnt]=head[u];to[cnt]=v;</span><br><span class="line">    w[cnt]=w0;head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(ll f[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[i]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">            <span class="keyword">if</span>(f[to[i]]&gt;f[u]+w[i]) f[to[i]]=f[u]+w[i],q.<span class="built_in">emplace</span>(f[to[i]],to[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll f[<span class="number">33</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">int</span> m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,x;i&lt;k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),f[<span class="number">1</span>&lt;&lt;i][x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w),<span class="built_in">add</span>(u,v,w),<span class="built_in">add</span>(v,u,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;<span class="number">1</span>&lt;&lt;k;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=(s<span class="number">-1</span>)&amp;s;t;t=(t<span class="number">-1</span>)&amp;s) f[s][u]=<span class="built_in">min</span>(f[s][u],f[t][u]+f[s^t][u]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++) <span class="keyword">if</span>(f[s][u]&lt;=inf) q.<span class="built_in">emplace</span>(f[s][u],u);</span><br><span class="line">        <span class="built_in">dij</span>(f[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,*<span class="built_in">min_element</span>(f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>]+<span class="number">1</span>,f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>]+n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="F-Swap"><a href="#F-Swap" class="headerlink" title="F. Swap"></a>F. Swap</h2><p>题目给的序列可以看成一棵完全二叉树，其中一个节点可以依次和左右儿子交换。</p>
<p>不妨假设根，左儿子，右儿子分别是 $a,b,c$。</p>
<ul>
<li>$a &lt; \min(b,c)$，显然什么都不干。</li>
<li>$b&lt; a$，必然只能交换 $a,b$。</li>
<li>$c&lt; \min(a,b)$，根必然是 $c$，左右儿子可以是 $a,b$ 也可以是 $b,a$。</li>
</ul>
<p>问题在于 $a,b$ 优还是 $b,a$ 更优不能直接判断。</p>
<p>不妨假设 $a&lt; b$，如果 $a$ 放到左子树后最后的位置是 $p$，那么 $b$ 放到左子树后 $p$ 位置的值一定会变大。右子树同理。所以只需要看 $a$ 放到左子树后的位置与放到右子树的位置哪一个靠前即可。</p>
<p>所以假设 $a$ 被放入左子树，利用类似的策略可以确定 $a$ 最终位置。于是就可以推出 $a$ 被放入左子树优还是右子树优。</p>
<p>考虑分析时间复杂度：注意到一个事情，就是假设 $v$ 放入 $u$ 时，必然有 $v$ 是 $u$ 的祖先或者祖先的兄弟，换句话说合法 $v$ 取值只有 $2\log n$ 个。直接用 <code>map</code> 记忆化搜索，这样一个点只会被访问 $O(\log n)$ 次。</p>
<p>总复杂度 $O(n\log^2 n)$，并且跑不太满。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> p[N],n;</span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span><span class="comment">//if p_u becomes v</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(&#123;u,v&#125;)) <span class="keyword">return</span> mp[&#123;u,v&#125;];</span><br><span class="line">    <span class="keyword">int</span> &amp;b=p[u&lt;&lt;<span class="number">1</span>],&amp;c=p[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],&amp;w=mp[&#123;u,v&#125;];</span><br><span class="line">    <span class="keyword">if</span>(v&lt;<span class="built_in">min</span>(b,c)) <span class="keyword">return</span> w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;c) <span class="keyword">return</span> w=<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>,v)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b&lt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>,b)&gt;<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,b)) <span class="keyword">return</span> w=<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>,v)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> w=<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,v)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> w=<span class="built_in">min</span>(<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>,v),<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,v))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;a=p[u],&amp;b=p[u&lt;&lt;<span class="number">1</span>],&amp;c=p[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="built_in">min</span>(b,c))&#123;<span class="built_in">solve</span>(u&lt;&lt;<span class="number">1</span>);<span class="built_in">solve</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;c)&#123;<span class="built_in">swap</span>(a,b);<span class="built_in">solve</span>(u&lt;&lt;<span class="number">1</span>);<span class="built_in">solve</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d: %d, &quot;,u&lt;&lt;1,min(a,b),find(u&lt;&lt;1,min(a,b)));</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d %d: %d\n&quot;,u&lt;&lt;1|1,min(a,b),find(u&lt;&lt;1|1,min(a,b)));</span></span><br><span class="line">    <span class="built_in">swap</span>(a,c);<span class="keyword">if</span>(b&gt;c) <span class="built_in">swap</span>(b,c);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>,b)&gt;<span class="built_in">find</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,b)) <span class="built_in">swap</span>(b,c);</span><br><span class="line">    <span class="built_in">solve</span>(u&lt;&lt;<span class="number">1</span>);<span class="built_in">solve</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">1</span>;i++) p[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>BOI</tag>
        <tag>Virtual participation</tag>
      </tags>
  </entry>
  <entry>
    <title>Baltic Olympiad in Informatics 2018</title>
    <url>/2021/11/07/BOI2018/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">polygon</th>
<th align="center">dna</th>
<th align="center">worm</th>
<th align="center">alternating</th>
<th align="center">genetics</th>
<th align="center">paths</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center"><a title="赛时 55">$\color{red}{\texttt{+}}$</a></td>
<td align="center">$\color{red}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
</tr>
</tbody></table>
<h2 id="链接-题面链接-中文题面"><a href="#链接-题面链接-中文题面" class="headerlink" title="链接 题面链接 中文题面"></a><a href="https://cses.fi/204/list/">链接</a> <a href="https://cses.fi/file/a6f5102dbde70511b4692e5e1a166843039b2b723d709c5f41cdff427b7dc37a/">题面链接</a> <a href="https://loj.ac/p?tagIds=205,212">中文题面</a></h2><span id="more"></span>

<h2 id="A-Love-Polygon"><a href="#A-Love-Polygon" class="headerlink" title="A. Love Polygon"></a>A. Love Polygon</h2><p>注意到一个点至少有一条出边，而总边数是 $n$，所以这是一棵基环内向树。</p>
<p>除去原本的二元环，实际上答案就是 $n-匹配数$。</p>
<p>找出每一个块，非环部分先贪心匹配。如果环上有点已经被匹配了就从该点开始，否则任取一个点开始贪心匹配，容易证明是正确的。</p>
<p>复杂度 $O(n)$</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="keyword">int</span> cir[N],T;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line"><span class="keyword">int</span> ans;<span class="keyword">bool</span> col[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;vis[u]=<span class="literal">true</span>;<span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="keyword">if</span>(cir[v]!=T)&#123;<span class="built_in">dfs</span>(v);<span class="keyword">if</span>(!col[u] &amp;&amp; !col[v]) col[u]=col[v]=<span class="literal">true</span>,++ans;&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;cin&gt;&gt;n;<span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,tt=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s1,s2;cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(s1)) mp[s1]=++tt;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(s2)) mp[s2]=++tt;</span><br><span class="line">        <span class="keyword">int</span> u=mp[s1],v=mp[s2];</span><br><span class="line">        <span class="keyword">if</span>(fa[u])&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        fa[u]=v;g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!fa[i])&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!vis[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=i;</span><br><span class="line">        ++T;<span class="keyword">for</span>(;cir[u]!=T;u=fa[u]) cir[u]=T;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;c;</span><br><span class="line">        ++T;<span class="keyword">for</span>(;cir[u]!=T;u=fa[u]) cir[u]=T,c.<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(c.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;col[c[<span class="number">0</span>]]=col[c[<span class="number">1</span>]]=<span class="literal">true</span>,ans+=<span class="number">2</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:c) <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(c.<span class="built_in">size</span>()&lt;=<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> w=u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:c) <span class="keyword">if</span>(col[v])&#123;w=v;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=fa[w];v!=w;v=fa[v]) <span class="keyword">if</span>(!col[v] &amp;&amp; !col[fa[v]]) col[v]=col[fa[v]]=<span class="literal">true</span>,++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-Martian-DNA"><a href="#B-Martian-DNA" class="headerlink" title="B. Martian DNA"></a>B. Martian DNA</h2><p>签到题，直接双指针扫过去即可。</p>
<p>复杂度 $O(n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> res,a[N],d[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>((++c[x])==d[x]) ++res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>((c[x]--)==d[x]) --res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),d[x]=y;</span><br><span class="line">    <span class="keyword">int</span> ans=n+<span class="number">1</span>;res=m-k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=n &amp;&amp; res!=m) <span class="built_in">add</span>(a[j++]);</span><br><span class="line">        <span class="keyword">if</span>(res!=m) <span class="keyword">break</span>;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,j-i);</span><br><span class="line">        <span class="built_in">del</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;n) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Worm-Worries"><a href="#C-Worm-Worries" class="headerlink" title="C. Worm Worries"></a>C. Worm Worries</h2><p>这道题本质上有三个子任务。</p>
<details>
    <summary>子任务 1 (subtask 1,2)</summary>

<p><strong>子任务 1 约束</strong>：$M = K = 1, N = 10^6, Q = 35$</p>
<p>显然有一个查询次数 $2\log_2 N$ 的做法：每次查询中点与其右边的点，舍去较小权值对应的一半序列。容易证明，较大权值的部分一定存在可行的峰值。</p>
<p>毛估估一下要 $40$ 次，恰好过不去。</p>
<p>考虑优化：上述做法每次要用 2 个询问，有点浪费。</p>
<p>事实上如果询问点在 $x,y$，有 $a_x&lt;a_y$，那么 $[1,x]$ 部分同样可以舍掉。</p>
<p>事实上取 $x$ 为黄金分割点（大约为 $0.38$），每次将 $y$ 取另一黄金分割点，每次可以舍去 $\phi$ 的部分，询问次数为 $\log_{\phi}n$，算一下大概 $30$ 次，可以通过。</p>
</details>

<details>
    <summary>子任务 2 (subtask 3,4)</summary>

<p><strong>子任务 2 约束</strong>：$K = 1, N=M=1000,Q=3500$</p>
<p>考虑每次取较长边的一半（不妨假设为横坐标），分成两段，找到其中的最大值，扩展最大值周围的格子。</p>
<p>容易证明，当前极值在右边，如果最终极值在左边，一定会有当前极值引出的一条路径穿过中间的查询点，那么一定会被更新最大值。所以如果已知的最大值（包括之前询问得到的）在右边，那么递归处理右边的格子，否则递归左边格子一定合法。</p>
<p>$$T(n)=T(\frac n2)+1.5n$$</p>
<p>毛估估一下可以通过。</p>
</details>

<details>
    <summary>子任务 3 (subtask 5,6)</summary>

<p>subtask 5 可以用类似子任务 2 的方法处理。</p>
<p><strong>子任务 3 约束</strong>：$N = M = K = 500, Q = 1.5\times 10^5$</p>
<p>考虑一种很自然的想法：每次随机 $\frac Q2$ 个点，取其中最大的点，贪心向其四周查找最大值并转移。</p>
<p>分析一下正确概率：</p>
<p>不妨考虑最坏情况，一次转移认为要 $6$ 次查询，那么要能在 $\frac Q2$ 步内到达极大值，初始点一定要在前 $\frac Q{12}$ 大的点中。成功概率为：</p>
<p>$$1-(1-\frac{Q}{12NMK})^{\frac Q2}$$</p>
<p>用 python 算一下大约是 $97.6%$。</p>
<p>事实上上述式子根本跑不满，如果认为一次转移期望 $3$ 次查询，就有 $99.94%$ 的正确率。事实上正确率比这个更高。</p>
</details>

<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;? %d %d %d\n&quot;</span>,x,y,z);<span class="built_in">fflush</span>(stdout);<span class="keyword">int</span> r;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);<span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k,Q;</span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Rand</span>()%(r-l+<span class="number">1</span>)+l;&#125;</span><br><span class="line"><span class="keyword">namespace</span> c1&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line">    <span class="keyword">int</span> a[N],qt=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(a[x]) <span class="keyword">return</span> a[x];++qt;<span class="keyword">int</span> r=<span class="number">0</span>;<span class="built_in">printf</span>(<span class="string">&quot;? %d 1 1\n&quot;</span>,x);<span class="built_in">fflush</span>(stdout);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);<span class="keyword">return</span> a[x]=r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getl</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> l+(r-l+<span class="number">1</span>)*<span class="number">0.38</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> r-(r-l+<span class="number">1</span>)*<span class="number">0.38</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;<span class="built_in">printf</span>(<span class="string">&quot;! %d 1 1\n&quot;</span>,l);cerr&lt;&lt;qt&lt;&lt;endl;<span class="built_in">fflush</span>(stdout);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(r-l&lt;=<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">qry</span>(mid)&gt;<span class="built_in">qry</span>(mid+<span class="number">1</span>)) <span class="built_in">solve</span>(l,mid);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p) p=<span class="built_in">getl</span>(l,r);</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=mid) u=<span class="built_in">getr</span>(l,p);</span><br><span class="line">        <span class="keyword">else</span> u=<span class="built_in">getl</span>(p,r),<span class="built_in">swap</span>(u,p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(u)&lt;<span class="built_in">qry</span>(p)) <span class="built_in">solve</span>(u+<span class="number">1</span>,r,p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solve</span>(l,p<span class="number">-1</span>,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int a[110][110];</span></span><br><span class="line"><span class="keyword">namespace</span> c2&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line">    <span class="keyword">int</span> mp[N][N],mx,my;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][y]&lt;=mp[mx][my]) <span class="keyword">return</span>;</span><br><span class="line">        mx=x,my=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span> || y&lt;=<span class="number">0</span> || x&gt;n || y&gt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][y]) <span class="keyword">return</span> mp[x][y];</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;? %d %d 1\n&quot;</span>,x,y);<span class="built_in">fflush</span>(stdout);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,r);</span></span><br><span class="line">        mp[x][y]=r;</span><br><span class="line">        <span class="built_in">upd</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">answer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d %d 1\n&quot;</span>,x,y);</span><br><span class="line">        cerr&lt;&lt;mx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;my&lt;&lt;endl;</span><br><span class="line">        cerr&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(mx!=x || my!=y) <span class="keyword">throw</span>;</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> xl,<span class="keyword">int</span> xr,<span class="keyword">int</span> yl,<span class="keyword">int</span> yr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xl==xr &amp;&amp; yl==yr) <span class="built_in">answer</span>(xl,yl);</span><br><span class="line">        <span class="keyword">if</span>(xr-xl&gt;=yr-yl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xm=(xl+xr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mw=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=yl;i&lt;=yr;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> w=<span class="built_in">qry</span>(xm,i);</span><br><span class="line">                <span class="keyword">if</span>(w&gt;mw) mw=w,p=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">qry</span>(xm+<span class="number">1</span>,p);<span class="built_in">qry</span>(xm<span class="number">-1</span>,p);</span><br><span class="line">            <span class="keyword">if</span>(mx==xm) <span class="built_in">answer</span>(xm,p);</span><br><span class="line">            <span class="keyword">if</span>(mx&gt;xm) <span class="built_in">solve</span>(xm+<span class="number">1</span>,xr,yl,yr);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">solve</span>(xl,xm<span class="number">-1</span>,yl,yr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ym=(yl+yr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mw=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=xl;i&lt;=xr;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> w=<span class="built_in">qry</span>(i,ym);</span><br><span class="line">                <span class="keyword">if</span>(w&gt;mw) mw=w,p=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">qry</span>(p,ym+<span class="number">1</span>);<span class="built_in">qry</span>(p,ym<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(my==ym) <span class="built_in">answer</span>(p,ym);</span><br><span class="line">            <span class="keyword">if</span>(my&gt;ym) <span class="built_in">solve</span>(xl,xr,ym+<span class="number">1</span>,yr);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">solve</span>(xl,xr,yl,ym<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> c3&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> mp[N][N][N],mx,my,mz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][y][z]&lt;=mp[mx][my][mz]) <span class="keyword">return</span>;</span><br><span class="line">        mx=x,my=y,mz=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span> || y&lt;=<span class="number">0</span> || z&lt;=<span class="number">0</span> || x&gt;n || y&gt;m || z&gt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][y][z]) <span class="keyword">return</span> mp[x][y][z];</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;? %d %d %d\n&quot;</span>,x,y,z);<span class="built_in">fflush</span>(stdout);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,r);</span></span><br><span class="line">        mp[x][y][z]=r;</span><br><span class="line">        <span class="built_in">upd</span>(x,y,z);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">answer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d %d %d\n&quot;</span>,x,y,z);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> xl,<span class="keyword">int</span> xr,<span class="keyword">int</span> yl,<span class="keyword">int</span> yr,<span class="keyword">int</span> zl,<span class="keyword">int</span> zr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xl==xr &amp;&amp; yl==yr &amp;&amp; zl==zr) <span class="built_in">answer</span>(xl,yl,zl);</span><br><span class="line">        <span class="keyword">if</span>(xr-xl&gt;=yr-yl &amp;&amp; xr-xl&gt;=zr-zl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xm=(xl+xr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mw=<span class="number">0</span>,py=<span class="number">0</span>,pz=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=yl;i&lt;=yr;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=zl;j&lt;=zr;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> w=<span class="built_in">qry</span>(xm,i,j);</span><br><span class="line">                    <span class="keyword">if</span>(w&gt;mw) mw=w,py=i,pz=j;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">qry</span>(xm+<span class="number">1</span>,py,pz);<span class="built_in">qry</span>(xm<span class="number">-1</span>,py,pz);</span><br><span class="line">            <span class="keyword">if</span>(mx==xm) <span class="built_in">answer</span>(xm,py,pz);</span><br><span class="line">            <span class="keyword">if</span>(mx&gt;xm) <span class="built_in">solve</span>(xm+<span class="number">1</span>,xr,yl,yr,zl,zr);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">solve</span>(xl,xm<span class="number">-1</span>,yl,yr,zl,zr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(yr-yl&gt;=xr-xl &amp;&amp; yr-yl&gt;=zr-zl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ym=(yl+yr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mw=<span class="number">0</span>,px=<span class="number">0</span>,pz=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=xl;i&lt;=xr;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=zl;j&lt;=zr;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> w=<span class="built_in">qry</span>(i,ym,j);</span><br><span class="line">                    <span class="keyword">if</span>(w&gt;mw) mw=w,px=i,pz=j;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">qry</span>(px,ym+<span class="number">1</span>,pz);<span class="built_in">qry</span>(px,ym<span class="number">-1</span>,pz);</span><br><span class="line">            <span class="keyword">if</span>(my==ym) <span class="built_in">answer</span>(px,ym,pz);</span><br><span class="line">            <span class="keyword">if</span>(my&gt;ym) <span class="built_in">solve</span>(xl,xr,ym+<span class="number">1</span>,yr,zl,zr);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">solve</span>(xl,xr,yl,ym<span class="number">-1</span>,zl,zr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> zm=(zl+zr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mw=<span class="number">0</span>,px=<span class="number">0</span>,py=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=xl;i&lt;=xr;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=yl;j&lt;=yr;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> w=<span class="built_in">qry</span>(i,j,zm);</span><br><span class="line">                    <span class="keyword">if</span>(w&gt;mw) mw=w,px=i,py=j;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">qry</span>(px,py,zm+<span class="number">1</span>);<span class="built_in">qry</span>(px,py,zm<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mz==zm) <span class="built_in">answer</span>(px,py,zm);</span><br><span class="line">            <span class="keyword">if</span>(mz&gt;zm) <span class="built_in">solve</span>(xl,xr,yl,yr,zm+<span class="number">1</span>,zr);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">solve</span>(xl,xr,yl,yr,zl,zm<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> all&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">node</span>(<span class="keyword">int</span> X=<span class="number">0</span>,<span class="keyword">int</span> Y=<span class="number">0</span>,<span class="keyword">int</span> Z=<span class="number">0</span>):<span class="built_in">x</span>(X),<span class="built_in">y</span>(Y),<span class="built_in">z</span>(Z)&#123;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x==a.x?(y==a.y?z&lt;a.z:y&lt;a.y):x&lt;a.x;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line">    map&lt;node,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">int</span> mx,my,mz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[<span class="built_in">node</span>(x,y,z)]&lt;=mp[<span class="built_in">node</span>(mx,my,mz)]) <span class="keyword">return</span>;</span><br><span class="line">        mx=x,my=y,mz=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">answer</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;! %d %d %d\n&quot;</span>,x,y,z);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span> || y&lt;=<span class="number">0</span> || z&lt;=<span class="number">0</span> || x&gt;n || y&gt;m || z&gt;k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp[<span class="built_in">node</span>(x,y,z)]) <span class="keyword">return</span> mp[<span class="built_in">node</span>(x,y,z)];</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;? %d %d %d\n&quot;</span>,x,y,z);<span class="built_in">fflush</span>(stdout);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,r);</span></span><br><span class="line">        mp[<span class="built_in">node</span>(x,y,z)]=r;</span><br><span class="line">        <span class="built_in">upd</span>(x,y,z);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=Q/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(t --&gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">range</span>(<span class="number">1</span>,n),y=<span class="built_in">range</span>(<span class="number">1</span>,m),z=<span class="built_in">range</span>(<span class="number">1</span>,k);</span><br><span class="line">            <span class="built_in">qry</span>(x,y,z);Q--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node <span class="title">find_bigger</span><span class="params">(node a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="built_in">qry</span>(a.x,a.y,a.z);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(a.x+<span class="number">1</span>,a.y,a.z)&gt;t) <span class="keyword">return</span> <span class="built_in">node</span>(a.x+<span class="number">1</span>,a.y,a.z);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(a.x,a.y+<span class="number">1</span>,a.z)&gt;t) <span class="keyword">return</span> <span class="built_in">node</span>(a.x,a.y+<span class="number">1</span>,a.z);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(a.x,a.y,a.z+<span class="number">1</span>)&gt;t) <span class="keyword">return</span> <span class="built_in">node</span>(a.x,a.y,a.z+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(a.x<span class="number">-1</span>,a.y,a.z)&gt;t) <span class="keyword">return</span> <span class="built_in">node</span>(a.x<span class="number">-1</span>,a.y,a.z);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(a.x,a.y<span class="number">-1</span>,a.z)&gt;t) <span class="keyword">return</span> <span class="built_in">node</span>(a.x,a.y<span class="number">-1</span>,a.z);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">qry</span>(a.x,a.y,a.z<span class="number">-1</span>)&gt;t) <span class="keyword">return</span> <span class="built_in">node</span>(a.x,a.y,a.z<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">answer</span>(a.x,a.y,a.z);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="function">node <span class="title">a</span><span class="params">(mx,my,mz)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) a=<span class="built_in">find_bigger</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;Q);</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; k==<span class="number">1</span>) c1::<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) c2::<span class="built_in">solve</span>(<span class="number">1</span>,n,<span class="number">1</span>,m);</span><br><span class="line">    <span class="comment">// c3::solve(1,n,1,m,1,k);</span></span><br><span class="line">    all::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E-Genetics"><a href="#E-Genetics" class="headerlink" title="E. Genetics"></a>E. Genetics</h2><p>首先显然有一个 $O(\frac{n^3}{\omega})$ 的做法，卡一卡常在 LOJ 上能过。这里考虑一个高明的 $O(n^2)$ 做法：</p>
<p>定义每个字符串长度为 $m$。</p>
<p>如果我们定义第 $i$ 个字符串价值是 $m^i$，定义 $f(i,j)$ 表示第 $i$ 个字符串与第 $j$ 个字符串不同字符个数乘上 $m^j$，要对于每个 $i$ 求 $g_i=\sum f(i,j)$。显然只要对每个位置的某个字符统计贡献即可 $O(n)$ 计算。</p>
<p>可以发现 $g_i=k\sum_{j\neq i}m^j$ 当且仅当字符串 $i$ 是要找的那个串。</p>
<p>事实上并不需要权值为 $m^i$，只需要钦定一个随机价值即可。可以证明上述做法在 <code>long long</code> 范围内随机的错误概率大约是 $2^{-50}$。</p>
<details>
    <summary> 代码 </summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pos</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="keyword">return</span> c==<span class="string">&#x27;A&#x27;</span>?<span class="number">0</span>:(c==<span class="string">&#x27;C&#x27;</span>?<span class="number">1</span>:(c==<span class="string">&#x27;G&#x27;</span>?<span class="number">2</span>:<span class="number">3</span>));&#125;</span><br><span class="line"><span class="function">mt19937 <span class="title">Rand</span><span class="params">(std::chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">ll p[N],f[N][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">bool</span> only=<span class="literal">true</span>;ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]),p[i]=<span class="built_in">Rand</span>(),sum+=p[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) f[j][<span class="built_in">pos</span>(s[i][j])]-=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) f[i][j]+=sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) res+=f[j][<span class="built_in">pos</span>(s[i][j])];</span><br><span class="line">        <span class="keyword">if</span>(res==k*(sum-p[i]))&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i+<span class="number">1</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="F-Paths"><a href="#F-Paths" class="headerlink" title="F. Paths"></a>F. Paths</h2><p>签到题。</p>
<p>令 $f_{i,S}$ 表示到点 $i$，其中 $S$ 子集的颜色已经走过的方案数。直接 dp 即可。复杂度 $O(m2^k)$。</p>
<details>
    <summary> 代码 </summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> col[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line">ll f[N][<span class="number">1</span>&lt;&lt;M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;col[i]),col[i]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">1</span>&lt;&lt;col[i]]=<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;<span class="number">1</span>&lt;&lt;k;s++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++) <span class="keyword">if</span>(f[u][s])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="keyword">if</span>(!(s&gt;&gt;col[v]&amp;<span class="number">1</span>)) f[v][s^(<span class="number">1</span>&lt;&lt;col[v])]+=f[u][s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s&lt;<span class="number">1</span>&lt;&lt;k;s++) ans+=f[u][s];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans-n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>BOI</tag>
        <tag>Virtual participation</tag>
      </tags>
  </entry>
  <entry>
    <title>Baltic Olympiad in Informatics 2019</title>
    <url>/2021/11/01/BOI2019/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"><a href="http://boi2019.eio.ee/wp-content/uploads/2019/04/flash.en_.pdf">Flash</a></th>
<th align="center"><a href="http://boi2019.eio.ee/wp-content/uploads/2019/04/nautilus.en_.pdf">Nautilus</a></th>
<th align="center"><a href="http://boi2019.eio.ee/wp-content/uploads/2019/04/valley.en_.pdf">Valley</a></th>
<th align="center"><a href="http://boi2019.eio.ee/wp-content/uploads/2019/05/kitchen.en_.pdf">Kitchen</a></th>
<th align="center"><a href="http://boi2019.eio.ee/wp-content/uploads/2019/05/necklace.en_.pdf">Necklace</a></th>
<th align="center"><a href="hhttp://boi2019.eio.ee/wp-content/uploads/2019/05/olymp.en_.pdf">Olympiads</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+1}}$</td>
<td align="center">$\color{green}{\texttt{+1}}$</td>
<td align="center">$\color{red}{\texttt{+2}}$</td>
</tr>
</tbody></table>
<h2 id="链接-题面链接-中文题面"><a href="#链接-题面链接-中文题面" class="headerlink" title="链接 题面链接 中文题面"></a><a href="https://cses.fi/247/list/">链接</a> <a href="https://cses.fi/file/170de9ffff44bee95c34d021455ba0a148873d69e7a5ae7e05c1ddd7bed09618/">题面链接</a> <a href="https://loj.ac/p?tagIds=212,258">中文题面</a></h2><span id="more"></span>

<h2 id="B-Nautilus"><a href="#B-Nautilus" class="headerlink" title="B. Nautilus"></a>B. Nautilus</h2><p>考虑用 $f_{i,j,t}$ 表示点 $(i,j)$ 是否可能在 $t$ 时间被到达。显然可以 $O(1)$ 转移。</p>
<p>注意到转移都是或操作，直接 bitset 优化。复杂度 $O(\frac{n^2m}{\omega})$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 502</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">bitset&lt;N&gt;f[N],g[N],mp[N];</span><br><span class="line"><span class="keyword">char</span> s[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="keyword">if</span>(s[j]==<span class="string">&#x27;.&#x27;</span>) mp[i].<span class="built_in">set</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=mp[i];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i]=f[i],f[i].<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;N&#x27;</span> || s[i]==<span class="string">&#x27;?&#x27;</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]|=g[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;S&#x27;</span> || s[i]==<span class="string">&#x27;?&#x27;</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]|=g[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span> || s[i]==<span class="string">&#x27;?&#x27;</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]|=g[i]&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;E&#x27;</span> || s[i]==<span class="string">&#x27;?&#x27;</span>) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]|=g[i]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]&amp;=mp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=f[i].<span class="built_in">count</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Valley"><a href="#C-Valley" class="headerlink" title="C. Valley"></a>C. Valley</h2><p>题面给了一个点 $E$，换句话说如果断边不在 $u$ 到 $E$ 路径上直接输 <code>escaped</code>。</p>
<p>如果以 $E$ 为根，实际上断边等价于取一个子树。换句话说，如果父亲可达，那么其子树都可达。</p>
<p>考虑倍增，因为 $\text{dis}(x,y)=\text{dep}(x)+\text{dep}(y)-2\text{dep}(\operatorname{lca}(x,y))$，假设 $\text{lca}(x,y)$ 在 $y$ 向上 $2^i$ 的父亲中，取 $\min$ 即可。</p>
<p>最后查询倍增。复杂度 $O((n+q)\log n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 10000000000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],w[N&lt;&lt;<span class="number">1</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w0)</span></span>&#123;nxt[++cnt]=head[u];to[cnt]=v;w[cnt]=w0;head[u]=cnt;&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[N],fa[N],siz[N],idx;</span><br><span class="line">ll dis[N];<span class="keyword">int</span> rid[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++idx;siz[u]=<span class="number">1</span>,fa[u]=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v==p) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+w[i];rid[(i+<span class="number">1</span>)/<span class="number">2</span>]=v;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);siz[u]+=siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> col[N];ll h[N],f[N][<span class="number">22</span>],g[N][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[u]=col[u]?<span class="number">0</span>:inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[u]) <span class="built_in">dfs2</span>(to[i]),h[u]=<span class="built_in">min</span>(h[u],h[to[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rt,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i][<span class="number">0</span>]=h[i]-dis[i],f[i][<span class="number">0</span>]=fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;<span class="number">1</span>&lt;&lt;d&lt;=n;d++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i][d]=<span class="built_in">min</span>(g[i][d<span class="number">-1</span>],g[f[i][d<span class="number">-1</span>]][d<span class="number">-1</span>]),f[i][d]=f[f[i][d<span class="number">-1</span>]][d<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s,q;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;q,&amp;rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w),<span class="built_in">add</span>(u,v,w),<span class="built_in">add</span>(v,u,w);</span><br><span class="line">    <span class="built_in">dfs1</span>(rt,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=s;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x),col[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(rt);<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(q --&gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,d;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;d,&amp;u);</span><br><span class="line">        d=rid[d];</span><br><span class="line">        <span class="keyword">if</span>(dfn[d]&gt;dfn[u] || dfn[d]+siz[d]&lt;=dfn[u])&#123;<span class="built_in">puts</span>(<span class="string">&quot;escaped&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        ll res=inf,ex=dis[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(dis[f[u][i]]&gt;=dis[d]) res=<span class="built_in">min</span>(res,g[u][i]),u=f[u][i];</span><br><span class="line">        res=<span class="built_in">min</span>(res,g[u][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=<span class="number">1e15</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;oo&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res+ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="D-Kitchen"><a href="#D-Kitchen" class="headerlink" title="D. Kitchen"></a>D. Kitchen</h2><p>显然一个必要条件是 $\sum a_i\geq \sum b_i$ 且 $b_i\geq k$。</p>
<p>在这个条件下，我们可以先让每个厨师参与尽可能多的菜，最后再单独做。这样匹配就变成：左边每个点可以匹配 $a_i$ 个，右边强制匹配 $k$ 个，问是否合法。</p>
<p>由于 $\sum a_i\geq\sum b_i\geq nk$，上面的强制匹配可以看做是最大匹配为 $nk$。这是 Hall 定理的一个经典结论：最大匹配成立当且仅当 $\sum \max(a_i,n)\geq nk$。</p>
<p>用 $f_{i,j}$ 表示前 $i$ 个厨师，$\sum a_i$ 为 $j$ 时 $\sum \max(a_i,n)$ 的最大值。然后枚举所有 $\geq \sum b_i$ 且合法中最小的即可。复杂度 $O(n^3)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N*N],g[N*N];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),sa+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]),sb+=b[i];</span><br><span class="line">    <span class="keyword">if</span>(sa&gt;sb)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(a[i]&lt;k)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0xcf</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">0</span>;sb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(f,g,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=sb;j++)</span><br><span class="line">            g[j+b[i]]=<span class="built_in">max</span>(g[j+b[i]],f[j]+<span class="built_in">min</span>(b[i],n));</span><br><span class="line">        sb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sa;i&lt;=sb;i++)</span><br><span class="line">        <span class="keyword">if</span>(g[i]&gt;=n*k)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i-sa);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E-Necklace"><a href="#E-Necklace" class="headerlink" title="E. Necklace"></a>E. Necklace</h2><p>首先翻转可以直接将正串和反串分别匹配，可以不考虑。</p>
<p>重点在于串可以循环同构，不太好处理。不妨假设一个串可以表示为 $L+R$，另一个串表示为 $R+L$。考虑枚举两个串中的分界点 $p_1,p_2$：</p>
<p><img src="/image/2.png" alt="image"></p>
<p>直接枚举 $p_1,p_2$，Hash 判断 $L,R$ 是否合法，复杂度 $O(n^3)$。</p>
<p>考虑优化。不妨将 $S$ 和 $T$ 链接起来，中间放置一个特殊字符：</p>
<p><img src="/image/3.png" alt="image"></p>
<p>取 $p_1,p_2$ 中间的串 $S’$，可以发现 $R$ 就是 $S’$ 的 border。而枚举 $p_1$，所有 $p_2$ 的 border 可以在 $O(n)$ 时间算出。</p>
<p>同样将 $S$ 和 $T$ 翻转后拼接就可以得到 $R$。所以枚举 $p_1$，可以在 $O(n)$ 时间得到每个位置的 $L,R$ 长度，最后扫一遍更新答案即可。</p>
<p>复杂度 $O(n^2)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[N],t[N],tmp[N];</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> nxt[N],f[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;get %s :&quot;,tmp+1);</span></span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; tmp[p+<span class="number">1</span>]!=tmp[i]) p=nxt[p];</span><br><span class="line">        <span class="keyword">if</span>(tmp[p+<span class="number">1</span>]==tmp[i]) ++p;</span><br><span class="line">        nxt[i]=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=q;i++) printf(&quot;%d &quot;,nxt[i]);puts(&quot;&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putl</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&lt;=n;i++) tmp[++q]=s[i];</span><br><span class="line">    tmp[++q]=<span class="string">&#x27;$&#x27;</span>;<span class="keyword">int</span> l=q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) tmp[++q]=t[i];</span><br><span class="line">    <span class="built_in">get_nxt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[i]=nxt[i+l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putr</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i;i--) tmp[++q]=s[i];</span><br><span class="line">    tmp[++q]=<span class="string">&#x27;$&#x27;</span>;<span class="keyword">int</span> l=q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i;i--) tmp[++q]=t[i];</span><br><span class="line">    <span class="built_in">get_nxt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) g[m-i+<span class="number">1</span>]=nxt[i+l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,sl,tl;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=n;p++)<span class="comment">//在 p 位置断开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putl</span>(p);<span class="built_in">putr</span>(p<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,p);</span></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,f[i]);puts(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,g[i]);puts(&quot;&quot;);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i<span class="number">-1</span>]+g[i]&gt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=f[i<span class="number">-1</span>]+g[i];</span><br><span class="line">            sl=p-g[i];tl=i-f[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),m=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>);sl=n-(sl+ans<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>();sl=n-(sl+ans<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d %d\n&quot;</span>,ans,sl<span class="number">-1</span>,tl<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="F-Olympiads"><a href="#F-Olympiads" class="headerlink" title="F. Olympiads"></a>F. Olympiads</h2><p>很常见的套路。考虑一般的类似 $k$ 短路问题有两个方向，一个是 A* 乱搞，这里考虑另一种：</p>
<ul>
<li>首先求出所有可能方案中最大的那一个。在这道题里就是依次取每个项目中没有被选的人中最大的。</li>
<li>增广所有可能的次大值。可以发现如果指定前 $k$ 个位置，后面要最大同样会取没有被选的人中最大的。可以枚举 $k$，将 $k$ 取次大值，然后 $k+1\sim n$ 取最大值。</li>
<li>保证增广唯一。这个比较繁琐，因为事实上 ${1,2,3}$ 和 ${2,3,1}$ 应该是等价的。<br>  题解有一个比较好的实现方式，具体来说可以发现所有重复部分源于一个人 $u$ 如果被<strong>指定</strong>替换成另一个人 $v$ 之后，$u$ 又在后面出现了。<br>  所以我们钦定一个人如果被指定替换，那么他就不应该在后续出现。那么额外存一个集合表示仍然可以出现的人即可。</li>
</ul>
<p>最后只要依次取出优先队列中的元素，然后增广即可。</p>
<p>分析复杂度，一次增广会 push $O(k)$ 个元素，处理一个元素需要 $O(nk)$ 的时间，总增广次数 $O(c)$，所以总复杂度 $O(nk^2c+ck\log n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N][K];pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;a[K][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,chs[K],las;bitset&lt;N&gt;vis;</span><br><span class="line">    <span class="built_in">node</span>()&#123;v=las=<span class="number">0</span>;<span class="built_in">memset</span>(chs,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(chs));vis.<span class="built_in">reset</span>();&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a)<span class="keyword">const</span>&#123;<span class="keyword">return</span> v&lt;a.v;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;<span class="keyword">int</span> r=<span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) r=<span class="built_in">max</span>(r,w[chs[j]][i]); v+=r;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">get_next</span><span class="params">(<span class="keyword">const</span> node &amp;u,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node v=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l+<span class="number">1</span>;k&lt;=m;k++) v.vis[v.chs[k]]=<span class="literal">false</span>,v.chs[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=m;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!v.vis[a[k][i].se])&#123;v.chs[k]=a[k][i].se;v.vis[a[k][i].se]=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    v.las=l; v.<span class="built_in">init</span>();<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">fir</span><span class="params">()</span></span>&#123;node u;<span class="keyword">return</span> <span class="built_in">get_next</span>(u,<span class="number">1</span>);&#125;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]),a[j][i]=&#123;w[i][j],i&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">sort</span>(a[i]+<span class="number">1</span>,a[i]+n+<span class="number">1</span>,greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">fir</span>());</span><br><span class="line">    <span class="keyword">while</span>(k --&gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node u=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u.vis.<span class="built_in">count</span>()==n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=u.las;i&lt;=m;i++) q.<span class="built_in">push</span>(<span class="built_in">get_next</span>(u,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q.<span class="built_in">top</span>().v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>BOI</tag>
        <tag>Virtual participation</tag>
      </tags>
  </entry>
  <entry>
    <title>Baltic Olympiad in Informatics 2021</title>
    <url>/2021/10/31/BOI2021/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"><a href="https://www.boi2021.de/wp-content/uploads/2021/04/statement-boi2021-1-books-en.pdf">books</a></th>
<th align="center"><a href="https://www.boi2021.de/wp-content/uploads/2021/04/statement-boi2021-1-servers-en.pdf">servers</a></th>
<th align="center"><a href="https://www.boi2021.de/wp-content/uploads/2021/04/statement-boi2021-1-watchmen-en.pdf">watchmen</a></th>
<th align="center"><a href="https://www.boi2021.de/wp-content/uploads/2021/04/statement-boi2021-2-prison-en.pdf">prison</a></th>
<th align="center"><a href="https://www.boi2021.de/wp-content/uploads/2021/04/statement-boi2021-2-swaps-en.pdf">swaps</a></th>
<th align="center"><a href="https://www.boi2021.de/wp-content/uploads/2021/04/statement-boi2021-2-xanadu-en.pdf">xanadu</a></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+8}}$</td>
<td align="center">$\color{green}{\texttt{+2}}$</td>
<td align="center">$\color{green}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+1}}$</td>
<td align="center">$\color{green}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+1}}$</td>
</tr>
</tbody></table>
<h2 id="链接-题面链接"><a href="#链接-题面链接" class="headerlink" title="链接 题面链接"></a><a href="https://cses.fi/360/list/">链接</a> <a href="https://cses.fi/file/e13e34f6eaf05dc653b2b1ab884c2df9ccec23910cf2d918af6971fe81eae210/">题面链接</a></h2><span id="more"></span>

<h2 id="A-books"><a href="#A-books" class="headerlink" title="A. books"></a>A. books</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>交互题。给定 $n,k,A$。有一个长度为 $n$ 的递增序列 $a_i$，每次可以询问位置 $i$ 的权值，要求返回一个大小为 $m$ 的集合 $S$，满足 $\sum_{i\in S} a_i\in[A,2A]$。</p>
<p>$n\leq 25000,k\in[3,10]$。询问次数 $40$ 次。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑如果所有元素都 $&lt;A$ 的情况。可以发现 $[1,k]$ 一定是最小的和，$(n-k+1,n]$ 一定是最大的和。如果最小的和 $&gt;2A$ 或者最大的和 $&lt;A$ 那么直接无解。<br>否则可以发现相邻区间区间 $[i,i+k)$ 与 $(i,i+k]$ 之差 $&lt;A$，所以连续区间中一定有解。<br>二分位置 $p$ 查询 $[p,p+k)$ 的和，即可做到 $k\log n$ 次查询。</p>
<p>考虑有元素 $\geq A$ 的情况。其实这个很好处理：二分找到最小的 $x$ 使得 $x\geq A$，那么贪心地选一定取 $[1,k)$ 最优。如果 $[1,k)\cup{x}$ 不合法，那么任何有元素 $\geq A$ 的集合都不合法。</p>
<p>考虑优化询问复杂度。注意到其实我们只要构造一个子序列，满足这个子序列最小子区间 $\leq 2A$，最大子区间 $\geq A$，相邻区间差 $&lt;A$。</p>
<p>考虑先排除有元素 $\geq A$ 的情况，这样相邻区间差一定 $&lt;A$。假设 $n$ 为剩下序列长度。事实上我们只需要保留 $[1,k]\cup(n-k,n]$ 对应的子序列即可，此时上述三个条件都满足。<br>因为子序列长度只有 $2k$，直接暴力全部查出即可。</p>
<p>分析交互次数，总共 $O(k+\log n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;books.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">static</span> ll a[N];</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(a[x]) <span class="keyword">return</span> a[x];<span class="keyword">else</span> <span class="keyword">return</span> a[x]=<span class="built_in">skim</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lower</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=r;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">qry</span>(mid)&gt;=v) r=mid<span class="number">-1</span>,p=mid;<span class="keyword">else</span> l=mid+<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x[<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,ll lim,<span class="keyword">int</span> s0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> check=[&amp;](<span class="keyword">int</span> x[])&#123;ll s=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) cerr&lt;&lt;x[i]&lt;&lt;<span class="string">&quot; &quot;</span>,s+=<span class="built_in">qry</span>(x[i]);cerr&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;s&lt;&lt;endl;<span class="keyword">if</span>(s&gt;=lim &amp;&amp; s&lt;=<span class="number">2</span>*lim) <span class="built_in">answer</span>(vector&lt;<span class="keyword">int</span>&gt;(x+<span class="number">1</span>,x+k+<span class="number">1</span>));&#125;;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++) x[i]=i,s+=<span class="built_in">qry</span>(i);</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">2</span>*lim) <span class="built_in">impossible</span>();</span><br><span class="line">    n=<span class="built_in">get_lower</span>(<span class="number">1</span>,n,lim);</span><br><span class="line">    x[k]=n;<span class="built_in">check</span>(x);</span><br><span class="line">    cerr&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span> q=<span class="built_in">max</span>(n-k,<span class="number">0</span>),m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) x[++m]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) x[++m]=q+i;</span><br><span class="line">    <span class="built_in">sort</span>(x+<span class="number">1</span>,x+m+<span class="number">1</span>);m=<span class="built_in">unique</span>(x+<span class="number">1</span>,x+m+<span class="number">1</span>)-x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-k;i++) <span class="built_in">check</span>(x+i);</span><br><span class="line">    <span class="built_in">impossible</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="B-servers"><a href="#B-servers" class="headerlink" title="B. servers"></a>B. servers</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n$ 个点的树，每个点要维护一个集合 $S_u$，支持：</p>
<ol>
<li>选定一条树边 $(u,v)$，令 $S_u\leftarrow S_u\cup S_v\ ,\ S_v\leftarrow S_u\cup S_v$。即同时赋值为并集。保证每条树边都会被恰好操作$1$次。</li>
<li>询问 $u,v$，回答是否有 $v\in S_u$。</li>
<li>询问 $v$，回答 $\sum_u[v\in S_u]$ 即有多少个集合包含 $v$。</li>
</ol>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先离线把树建出来，这样相当于每条边有一个权值。</p>
<p>考虑点分治。首先处理 $2$ 操作。可以发现 $S_u$ 中要有 $v$ 当且仅当 $v$ 到 $u$ 路径权值单调递增且询问时间大于路径最大权值。这些都可以直接 dfs 解决。</p>
<p>考虑处理 $3$ 操作。对于每个点分中心我们处理的是该点在其点分子树外的贡献，即对于其他子树询问有多少能够到达，要求同样是路径单调增且询问时间大于路径最大权值。<br>先处理出上升路径与下降路径，把所有子树按与分治中心连边的权值从大到小排序，显然只有连边权值小的子树才有可能存在路径到连边权值大的子树。</p>
<p>由于下降路径最大值一定大于上升路径，所以只需要将下降路径的权值作为键值。这样等价于一个单点插入，询问 $\geq$ 某个键值的点数，直接树状数组即可。</p>
<p>分治中心位置的询问要额外判断。</p>
<p>复杂度 $O(n\log^2 n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 250010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],head[N],w[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w0)</span></span>&#123;nxt[++cnt]=head[u];to[cnt]=v;w[cnt]=w0;head[u]=cnt;&#125;</span><br><span class="line"><span class="keyword">bool</span> cut[N];</span><br><span class="line"><span class="keyword">namespace</span> find_root&#123;</span><br><span class="line">    <span class="keyword">int</span> siz[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs0</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;siz[u]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(!cut[to[i]] &amp;&amp; to[i]!=p) <span class="built_in">dfs0</span>(to[i],u),siz[u]+=siz[to[i]];&#125;</span><br><span class="line">    <span class="keyword">int</span> all,mxr,mx;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> r=all-siz[u];<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(!cut[to[i]] &amp;&amp; to[i]!=p) <span class="built_in">dfs1</span>(to[i],u),r=<span class="built_in">max</span>(r,siz[to[i]]);<span class="keyword">if</span>(r&lt;mx) mx=r,mxr=u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="built_in">dfs0</span>(u,<span class="number">0</span>);mx=all=siz[u],mxr=<span class="number">0</span>;<span class="built_in">dfs1</span>(u,<span class="number">0</span>);<span class="keyword">return</span> mxr;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> find_root::root;</span><br><span class="line"><span class="keyword">int</span> ans[N],n;</span><br><span class="line"><span class="keyword">namespace</span> solveQ&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q[N];</span><br><span class="line">    <span class="keyword">int</span> f[N],g[N],vis[N],T;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_up</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vis[u]=T;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v==p || cut[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;f[u]) f[v]=w[i],g[v]=g[u],<span class="built_in">dfs_up</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_down</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p,<span class="keyword">int</span> pre,<span class="keyword">int</span> fi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v==p || cut[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;pre) <span class="built_in">dfs_down</span>(v,u,w[i],fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w:q[u]) <span class="keyword">if</span>(w.se&gt;=pre &amp;&amp; vis[w.fi]==T &amp;&amp; g[w.fi]&lt;=fi) ans[w.se]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++T;</span><br><span class="line">        f[u]=<span class="number">1e8</span>;g[u]=<span class="number">0</span>;vis[u]=T;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;<span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(!cut[v]) f[v]=g[v]=w[i],<span class="built_in">dfs_up</span>(v,u);&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;<span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(!cut[v]) <span class="built_in">dfs_down</span>(v,u,w[i],w[i]);&#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w:q[u]) <span class="keyword">if</span>(vis[w.fi]==T &amp;&amp; w.se&gt;=g[w.fi]) ans[w.se]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> solveC&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;q[N];</span><br><span class="line">    <span class="keyword">int</span> tt[N],f[N];</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=N<span class="number">-10</span>;x+=x&amp;-x) a[x]+=v;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> v=<span class="number">0</span>;<span class="keyword">for</span>(;x;x-=x&amp;-x) v+=a[x];<span class="keyword">return</span> v;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_down</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p,<span class="keyword">int</span> pre,<span class="keyword">int</span> f,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(pre,val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v==p || cut[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;pre) <span class="built_in">dfs_down</span>(v,u,w[i],f,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_up</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p,<span class="keyword">int</span> pre,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:q[u]) <span class="keyword">if</span>(v&gt;f) ans[v]+=<span class="built_in">qry</span>(v)+<span class="number">1</span>;<span class="comment">//+1 is for the root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(v==p || cut[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;pre) <span class="built_in">dfs_up</span>(v,u,w[i],f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;son;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;<span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(!cut[v]) son.<span class="built_in">push_back</span>(v),f[v]=w[i];&#125;</span><br><span class="line">        <span class="built_in">sort</span>(son.<span class="built_in">begin</span>(),son.<span class="built_in">end</span>(),[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;<span class="keyword">return</span> f[x]&gt;f[y];&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:son)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs_up</span>(v,u,f[v],f[v]);</span><br><span class="line">            <span class="built_in">dfs_down</span>(v,u,f[v],f[v],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:q[u]) ans[v]+=<span class="built_in">qry</span>(v)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:son) <span class="built_in">dfs_down</span>(v,u,f[v],f[v],<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u=<span class="built_in">root</span>(u);cut[u]=<span class="literal">true</span>;</span><br><span class="line">    solveQ::<span class="built_in">solve</span>(u);</span><br><span class="line">    solveC::<span class="built_in">solve</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;<span class="keyword">int</span> v=to[i];<span class="keyword">if</span>(!cut[v]) <span class="built_in">solve</span>(v);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> is_qry[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];<span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y),<span class="built_in">add</span>(x,y,i),<span class="built_in">add</span>(y,x,i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y),++m,solveQ::q[x].<span class="built_in">emplace_back</span>(y,i),is_qry[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ++m,solveC::q[x].<span class="built_in">push_back</span>(i),is_qry[i]=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+k;i++) <span class="keyword">if</span>(is_qry[i]==<span class="number">1</span>) <span class="built_in">puts</span>(ans[i]?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_qry[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="D-prison"><a href="#D-prison" class="headerlink" title="D. prison"></a>D. prison</h2><p>首先显然有一个 $O(n\log^2 n)$ 的垃圾做法：</p>
<p>令 $l_i$ 表示如果 $i$ 要暴动，$[ l_i,i]$ 范围内不能有垫子。转化成平面上有若干线段，选 $k$ 个点使尽可能多的线段包含这些点。<br>显然这可以建出最小割模型故函数是凸的，用 wqs 二分 + 线段树即可做到 $O(n\log^2 n)$。</p>
<p>考虑一个结论：$\forall i&lt; j\ ,\ l_j\geq i\ \vee\ l_j\leq l_i$。这个很好证明，因为如果一个点能经过 $i$ 传到 $j$ 那么 $i$ 一定也动了。 这样任意两个线段要么相离要么包含。<br>令每个点的父亲为包含它的，题意转化成：给定一个森林，将 $d$ 个叶子到根路径染黑，问最多能染黑几个。</p>
<p>考虑一个贪心做法：每次选择一个到根白点最多的叶子染黑。证明可以考虑每次取一个点向上第一个没有被染黑的节点 $u$，那么 $u$ 为根子树内最深的点是 $u$ 中最优的点。</p>
<p>如果删除染黑的点，那么一次操作会将一棵树分裂为若干森林。不妨用堆维护森林的根对应子树深度最大值，容易发现一个点只会被加入与删除一次，故复杂度 $O(n\log n)$，可以通过。</p>
<p>而上述过程中所有值都 $\leq n$，所以用桶代替堆同时用一个指针枚举当前最大值可以做到 $O(n)$。 </p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> t[N],a[N];</span><br><span class="line"><span class="keyword">int</span> id[N],b[N],tp;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];<span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> U=<span class="number">0</span>,<span class="keyword">int</span> V=<span class="number">0</span>):<span class="built_in">u</span>(U),<span class="built_in">v</span>(V)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a,<span class="keyword">const</span> node b)&#123;<span class="keyword">return</span> a.v==b.v?a.u&lt;b.u:a.v&lt;b.v;&#125;</span><br><span class="line">node mx[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mx[u]=<span class="built_in">node</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="built_in">dfs</span>(v),mx[u]=<span class="built_in">max</span>(mx[u],mx[v]);</span><br><span class="line">    mx[u].v++;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,T;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;T);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(t[i]&lt;=T)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;++res;</span><br><span class="line">        <span class="keyword">while</span>(tp &amp;&amp; b[tp]&gt;=t[i]-i) tp--; </span><br><span class="line">        id[++tp]=i;b[tp]=t[i]-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(tp &amp;&amp; b[tp]+i&gt;T) tp--;</span><br><span class="line">        a[i]=id[tp];</span><br><span class="line">    &#125;</span><br><span class="line">    tp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) <span class="keyword">if</span>(i!=a[i] &amp;&amp; a[i]!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++res;</span><br><span class="line">        <span class="keyword">while</span>(tp &amp;&amp; b[tp]&gt;a[i]) tp--;</span><br><span class="line">        g[fa[i]=id[tp]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        id[++tp]=i,b[tp]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u:g[<span class="number">0</span>]) <span class="built_in">dfs</span>(u),q.<span class="built_in">push</span>(mx[u]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.<span class="built_in">top</span>().u;q.<span class="built_in">pop</span>();--m;</span><br><span class="line">        <span class="keyword">for</span>(;u &amp;&amp; !vis[u];u=fa[u])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(mx[v]);</span><br><span class="line">            --res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="F-xanadu"><a href="#F-xanadu" class="headerlink" title="F. xanadu"></a>F. xanadu</h2><p>全场真正的签到题。</p>
<p>直接 dp，用 $f_{i,0/1,0/1}$ 表示点 $i$，当前为 $0/1$，按过 $0/1$ 次按钮。</p>
<p>dp 时记录 $w_{0/1,0/1}$ 表示儿子全部为开/关，根是否被翻转。</p>
<p>复杂度 $O(n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line">ll f[N][<span class="number">2</span>][<span class="number">2</span>];<span class="keyword">int</span> a[N];</span><br><span class="line"><span class="comment">//f_&#123;i,0/1,0/1&#125; 点 i，当前为 0/1，按过 0/1 次按钮</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll h[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,inf&#125;,&#123;<span class="number">0</span>,inf&#125;&#125;,w[<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//所有儿子都是 0/1 且翻转 0/1 次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="keyword">if</span>(v!=p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">        w[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">min</span>(h[<span class="number">0</span>][<span class="number">0</span>]+f[v][<span class="number">0</span>][<span class="number">0</span>],h[<span class="number">0</span>][<span class="number">1</span>]+f[v][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        w[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">min</span>(h[<span class="number">0</span>][<span class="number">0</span>]+f[v][<span class="number">0</span>][<span class="number">1</span>],h[<span class="number">0</span>][<span class="number">1</span>]+f[v][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        w[<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">min</span>(h[<span class="number">1</span>][<span class="number">0</span>]+f[v][<span class="number">1</span>][<span class="number">0</span>],h[<span class="number">1</span>][<span class="number">1</span>]+f[v][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        w[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">min</span>(h[<span class="number">1</span>][<span class="number">0</span>]+f[v][<span class="number">1</span>][<span class="number">1</span>],h[<span class="number">1</span>][<span class="number">1</span>]+f[v][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">memcpy</span>(h,w,<span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">    &#125;</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">0</span>]=h[<span class="number">0</span>][a[u]];</span><br><span class="line">    f[u][<span class="number">0</span>][<span class="number">1</span>]=h[<span class="number">1</span>][!a[u]]+<span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">1</span>][<span class="number">0</span>]=h[<span class="number">0</span>][!a[u]];</span><br><span class="line">    f[u][<span class="number">1</span>][<span class="number">1</span>]=h[<span class="number">1</span>][a[u]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),g[u].<span class="built_in">push_back</span>(v),g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll res=<span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(res&gt;=inf) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>]]></content>
      <tags>
        <tag>BOI</tag>
        <tag>Virtual participation</tag>
      </tags>
  </entry>
  <entry>
    <title>Baltic Olympiad in Informatics 2020, Day 2</title>
    <url>/2021/10/27/CF1387/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/contest/1387">链接</a></h2><span id="more"></span>

<p>究极下饭.jpg</p>
<h2 id="A-Graph"><a href="#A-Graph" class="headerlink" title="A. Graph"></a>A. Graph</h2><p>考虑对每个连通块分别处理。</p>
<p>如果一个连通块是一棵树，直接设根节点是 $X$，然后可以用 $X$ 表示所有节点。最后要求是 $f(X)=\sum |X-a_i|$ 直接对 $a_i$ 排序求中位数即可。</p>
<p>如果连通块是一个二分图，事实上如果所有偶环合法，那么等价于一棵树，否则无解，所以最后再判一波是否合法即可。</p>
<p>对于存在奇环的图，可以发现一个奇环就可以唯一确定这个图的所有变量，随便处理即可。</p>
<p>复杂度 $O(n\log n)$。</p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a><a href="https://codeforces.com/contest/1387/submission/133110890">提交记录</a></h3><h2 id="B-Village"><a href="#B-Village" class="headerlink" title="B. Village"></a>B. Village</h2><p>这个构造总的来说还是比较水的。</p>
<p>首先是 Minimum 的部分。容易证明答案下界是 $2(n-匹配个数)$。</p>
<p>而且下界很容易达到：考虑贪心匹配一个点和一个未匹配的子节点，剩下子节点的连成一个环。最后根如果没有匹配强行插入任意一个子节点的环中。</p>
<p>然后是 Maximum 的部分。同样容易证明答案下界是以重心为根的子节点深度之和 $\times 2$。同样可以证明这也是答案上界：</p>
<ul>
<li>首先如果以除了重心以外的子节点为根，必然有若干匹配路径不经过根。那么将根想重心移到，这些不经过根的匹配路径不变，其余深度变大。</li>
<li>如果存在路径不经过根，那么一定存在另一条路径也不经过根，交换终点总长度变大。</li>
</ul>
<p>所以直接以重心为根，剩下随便构造一下即可。如果节点数为奇数，最后重心需要插入到任意一对匹配中。</p>
<h3 id="提交记录-Minimum"><a href="#提交记录-Minimum" class="headerlink" title="提交记录(Minimum)"></a><a href="https://codeforces.com/contest/1387/submission/133111598">提交记录(Minimum)</a></h3><h3 id="提交记录-Maximum"><a href="#提交记录-Maximum" class="headerlink" title="提交记录(Maximum)"></a><a href="https://codeforces.com/contest/1387/submission/133114087">提交记录(Maximum)</a></h3><h2 id="C-Viruses"><a href="#C-Viruses" class="headerlink" title="C. Viruses"></a>C. Viruses</h2><p>可以发现的是 $0$ 和 $1$ 是没有突变可能的，所以如果一个串变化过程中出现 $0,1$，那么这些 $0,1$ 就是固定的了。</p>
<p>如果没有抗体时怎么做：考虑用 $f_i$ 表示 $i$ 最小能变成多短的串，转移考虑用类似于 SPFA 的方式转移。</p>
<p>对于有抗体的情况：考虑建出所有抗体的 AC 自动机，那么 $0,1$ 串的任意子串都不能是该串的子串。</p>
<p>考虑更改 dp 式子。设 $f_{i,l,r}$ 表示字符 $i$，之前在 AC 自动机上的状态是 $l$，要变成 $r$ 且不能经过终止节点的最短距离。</p>
<p>对于每一个转移边，本质上是将上述 dp 转化成 $\min$ 矩阵形式，即</p>
<p>$$\prod_{i\in b} f_i$$</p>
<p>但是注意到这个 dp 可能会成环，不过我们要的是最短距离，所以不断增广，总转移数应该是 SPFA 的复杂度即 $O(nm)$，算一下是 $O(n^6)$。但众所周知 SPFA 复杂度特殊图根本卡不满，卡一卡常可以通过。</p>
<h3 id="提交记录-1"><a href="#提交记录-1" class="headerlink" title="提交记录"></a><a href="https://codeforces.com/contest/1387/submission/133165704">提交记录</a></h3>]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 031</title>
    <url>/2021/10/17/agc031/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://atcoder.jp/contests/agc031">链接</a></h2><span id="more"></span>

<h2 id="D-A-Sequence-of-Permutations"><a href="#D-A-Sequence-of-Permutations" class="headerlink" title="D. A Sequence of Permutations"></a>D. A Sequence of Permutations</h2><p>考虑 $f(p,q)=pq^{-1}$。枚举一下有：</p>
<p>$$<br>p\<br>q\<br>qp^-\<br>qp^-q^-\<br>qp^-q^-pq^-\<br>qp^-q^-ppq^-\<br>qp^-q^-pqpq^-\<br>qp^-q^-pqp^-qpq^-<br>$$</p>
<p>肉眼可见有 $qp^-q^-p$ 一直保留，所以本质上是一个 $6$ 的循环节。</p>
<p>那么直接快速幂即可。</p>
<p>复杂度 $O(n\log k)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perm</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="built_in">perm</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));&#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function">perm <span class="title">inv</span><span class="params">(perm &amp;a)</span></span>&#123;perm b;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[a[i]]=i;<span class="keyword">return</span> b;&#125;</span><br><span class="line">perm r,c;</span><br><span class="line">perm <span class="keyword">operator</span> *(perm a,perm b)&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]=a[b[i]];<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="function">perm <span class="title">ksm</span><span class="params">(perm a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) r[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=a*a) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=r*a;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">perm p,q,t,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);--k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    t=q*<span class="built_in">inv</span>(p)*<span class="built_in">inv</span>(q)*p;</span><br><span class="line">    ans=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k%<span class="number">6</span>;i++) ans=q,q=q*<span class="built_in">inv</span>(p),p=ans;</span><br><span class="line">    ans=<span class="built_in">ksm</span>(t,k/<span class="number">6</span>)*ans*<span class="built_in">ksm</span>(<span class="built_in">inv</span>(t),k/<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Snuke-the-Phantom-Thief"><a href="#E-Snuke-the-Phantom-Thief" class="headerlink" title="E. Snuke the Phantom Thief"></a>E. Snuke the Phantom Thief</h2><p>考虑行列分开算，可以发现一个 $\leq a_i$ 个数不超过 $b_i$ 限制，可以看做第 $b_i+1$ 个宝石必须 $&gt;a_i$。假设总共拿了 $k$ 颗宝石，那么一个 $\geq a_i$ 个数不超过 $b_i$ 限制可以看做第 $b_{k-i}$ 个宝石必须 $&lt;a_i$。</p>
<p>枚举 $k$，那么每个宝石等价于有一个 rank 的限制，排名必须在 $[l,r]$ 区间。</p>
<p>然后行列建点，行可行区间向宝石连边，宝石向列可行区间连边，每个宝石独自限流 $1$，跑最大费用最大流即可。</p>
<p>复杂度 $O(n^3m)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> __int128 lll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30010</span>,M=<span class="number">400010</span>,inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">const</span> ll winf=<span class="number">1000000000000000000ll</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">road</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,to,f;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;r[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> f,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[++cnt]=(road)&#123;head[u],v,f,w&#125;;head[u]=cnt;</span><br><span class="line">    r[++cnt]=(road)&#123;head[v],u,<span class="number">0</span>,-w&#125;;head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> MCMF&#123;</span><br><span class="line">    ll dis[N];</span><br><span class="line">    <span class="keyword">int</span> all,fl[N],pre[N],bef[N];</span><br><span class="line">    <span class="keyword">bool</span> in[N];</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++) dis[i]=-winf,fl[i]=inf,in[i]=<span class="literal">false</span>;</span><br><span class="line">        dis[s]=<span class="number">0</span>; pre[t]=<span class="number">-1</span>;in[s]=<span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            in[u]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=r[i].nxt)</span><br><span class="line">            <span class="keyword">if</span>(r[i].f)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v=r[i].to;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&lt;dis[u]+r[i].w)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v]=dis[u]+r[i].w;</span><br><span class="line">                    fl[v]=<span class="built_in">min</span>(fl[u],r[i].f);</span><br><span class="line">                    pre[v]=u,bef[v]=i;</span><br><span class="line">                    <span class="keyword">if</span>(!in[v]) in[v]=<span class="literal">true</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre[t]!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxf;ll minw;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">spfa</span>(s,t))</span><br><span class="line">        &#123;</span><br><span class="line">            maxf+=fl[t],minw+=fl[t]*dis[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u=t;u!=s;u=pre[u])</span><br><span class="line">            r[bef[u]].f-=fl[t],r[bef[u]^<span class="number">1</span>].f+=fl[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++) head[i]=dis[i]=<span class="number">0</span>;</span><br><span class="line">        all=<span class="number">0</span>;cnt=<span class="number">1</span>;</span><br><span class="line">        maxf=minw=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=<span class="built_in">min</span>(x,y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=<span class="built_in">max</span>(x,y);&#125;</span><br><span class="line"><span class="keyword">int</span> x[N],y[N];ll w[N];</span><br><span class="line"><span class="keyword">int</span> px[N],py[N],po[N];</span><br><span class="line"><span class="keyword">int</span> s,t,tt,n,m;</span><br><span class="line"><span class="keyword">int</span> lx[N],rx[N],ly[N],ry[N];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> id=[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> d)&#123;<span class="keyword">return</span> x+<span class="number">2</span>*k+d*n;&#125;;</span><br><span class="line">    s=<span class="built_in">id</span>(n,<span class="number">1</span>)+<span class="number">1</span>,t=s+<span class="number">1</span>;MCMF::all=t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">add</span>(s,i,<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">add</span>(i+k,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">add</span>(<span class="built_in">id</span>(i,<span class="number">0</span>),<span class="built_in">id</span>(i,<span class="number">1</span>),<span class="number">1</span>,w[i]),lx[i]=ly[i]=<span class="number">1</span>,rx[i]=ry[i]=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">if</span>(po[i]==<span class="number">0</span> &amp;&amp; py[i]+<span class="number">1</span>&lt;=k) <span class="built_in">chkmax</span>(lx[py[i]+<span class="number">1</span>],px[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(po[i]==<span class="number">1</span> &amp;&amp; py[i]+<span class="number">1</span>&lt;=k) <span class="built_in">chkmin</span>(rx[k-py[i]],px[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(po[i]==<span class="number">2</span> &amp;&amp; py[i]+<span class="number">1</span>&lt;=k) <span class="built_in">chkmax</span>(ly[py[i]+<span class="number">1</span>],px[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(po[i]==<span class="number">3</span> &amp;&amp; py[i]+<span class="number">1</span>&lt;=k) <span class="built_in">chkmin</span>(ry[k-py[i]],px[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++) <span class="built_in">chkmax</span>(lx[i],lx[i<span class="number">-1</span>]),<span class="built_in">chkmax</span>(ly[i],ly[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i;i--) <span class="built_in">chkmin</span>(rx[i],rx[i+<span class="number">1</span>]),<span class="built_in">chkmin</span>(ry[i],ry[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(lx[i]&lt;=x[j] &amp;&amp; x[j]&lt;=rx[i]) <span class="built_in">add</span>(i,<span class="built_in">id</span>(j,<span class="number">0</span>),<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(ly[i]&lt;=y[j] &amp;&amp; y[j]&lt;=ry[i]) <span class="built_in">add</span>(<span class="built_in">id</span>(j,<span class="number">1</span>),i+k,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    MCMF::<span class="built_in">work</span>(s,t);</span><br><span class="line">    <span class="keyword">if</span>(MCMF::maxf==k) ans=<span class="built_in">max</span>(ans,MCMF::minw);</span><br><span class="line">    MCMF::<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x[i],&amp;y[i],&amp;w[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;px[i],&amp;py[i]);</span><br><span class="line">        po[i]=(op[<span class="number">0</span>]==<span class="string">&#x27;L&#x27;</span>?<span class="number">0</span>:(op[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>?<span class="number">1</span>:(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>?<span class="number">2</span>:<span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Walk-on-Graph"><a href="#F-Walk-on-Graph" class="headerlink" title="F. Walk on Graph"></a>F. Walk on Graph</h2><p>神仙题。</p>
<p>首先可以发现如果一个点周围有边 $a$，那么来回走就能 $x\rightarrow 4x+3a$。如果同时有 $x\rightarrow 4x+3b$，由于 $4$ 在奇数模数下有逆元，所以有 $x\rightarrow x+(a-b)$。</p>
<p>不妨令 $g=\gcd{\Delta w}$，那么 $x$ 可以任意加上 $3qg,q\in \mathbb{Z}$。这样可以令 $\text{mod}’=\gcd(\text{mod},3g)$。</p>
<p>考虑将每个数字的状态用 $(p,q)=px+qg$ 表示，其中 $p$ 是 $2$ 的次幂。可以发现 $q\in[0,2]$，然后显然有 $(px,qg)\rightarrow (4px,4qg)=(4px,qg)$，所以 $p\in[1,2]$。</p>
<p>这样总共只有 $6$ 种状态，总共 $6n$ 个点，直接枚举每条边对应点连边即可。</p>
<p>考虑答案，可以发现最后要从状态 $(p,q)$ 走到 $(0,0)$，而且 $(p,q)$ 需要能表示 $r$，这个可以直接预处理，复杂度 $O(\text{mod})$。</p>
<p>总复杂度 $O(\text{mod}+(n+m+q)\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y==<span class="number">0</span>?x:<span class="built_in">gcd</span>(y,x%y);&#125;</span><br><span class="line"><span class="keyword">int</span> x[N],y[N],w[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==f[x]?f[x]:(f[x]=<span class="built_in">find</span>(f[x]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;x=<span class="built_in">find</span>(x);y=<span class="built_in">find</span>(y);<span class="keyword">if</span>(x!=y) f[x]=y;&#125;</span><br><span class="line"><span class="keyword">bool</span> pre[<span class="number">2</span>][<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q,mod,g=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q,&amp;mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x[i],&amp;y[i],&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++) g=<span class="built_in">gcd</span>(g,<span class="built_in">abs</span>(w[i]-w[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">if</span>(!g) g=mod;</span><br><span class="line">    <span class="keyword">else</span> mod=<span class="built_in">gcd</span>(mod,g*<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> w0=w[<span class="number">1</span>]%g;</span><br><span class="line">    <span class="keyword">auto</span> id=[&amp;](<span class="keyword">int</span> u,<span class="keyword">int</span> p,<span class="keyword">int</span> q)&#123;<span class="built_in"><span class="keyword">return</span></span> (u<span class="number">-1</span>)*<span class="number">6</span>+p*<span class="number">3</span>+q;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=w0;i&lt;mod*<span class="number">2</span>;i++,j=j*<span class="number">2</span>%mod) pre[i&amp;<span class="number">1</span>][j]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>*n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">2</span>;p++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;<span class="number">3</span>;q++)</span><br><span class="line">            <span class="built_in">merge</span>(<span class="built_in">id</span>(x[i],p,q),<span class="built_in">id</span>(y[i],!p,(<span class="number">2</span>*q+(w[i]-w0)/g)%<span class="number">3</span>)),</span><br><span class="line">            <span class="built_in">merge</span>(<span class="built_in">id</span>(y[i],p,q),<span class="built_in">id</span>(x[i],!p,(<span class="number">2</span>*q+(w[i]-w0)/g)%<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">auto</span> check=[&amp;](<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">2</span>;p++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;<span class="number">3</span>;q++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(<span class="built_in">id</span>(s,p,q))==<span class="built_in">find</span>(<span class="built_in">id</span>(t,<span class="number">0</span>,<span class="number">0</span>)) &amp;&amp; pre[p][(l+w0+(<span class="number">3</span>-q)*g)%mod]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(q --&gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s,t,l;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;t,&amp;l);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">check</span>(s,t,l)?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 032</title>
    <url>/2021/10/17/agc032/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://atcoder.jp/contests/agc032/tasks">链接</a></h2><span id="more"></span>

<h2 id="C-Three-Circuits"><a href="#C-Three-Circuits" class="headerlink" title="C. Three Circuits"></a>C. Three Circuits</h2><p>首先显然需要有欧拉回路，即所有点度数都是偶数。</p>
<p>假如有 $6$ 度的点或者超过两个 $4$ 度点一定合法。如果不到两个 $4$ 度点就不合法。</p>
<p>当有两个 $4$ 度点时，考虑是否连成两个环，直接删去一个 $4$ 度点后判是否连通即可。</p>
<p>复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> f[x]==x?f[x]:(f[x]=<span class="built_in">find</span>(f[x]));&#125;</span><br><span class="line"><span class="keyword">int</span> x[N],y[N],d[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x[i],&amp;y[i]),d[x[i]]++,d[y[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]&amp;<span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]&gt;<span class="number">4</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]==<span class="number">4</span>) c++;</span><br><span class="line">    <span class="keyword">if</span>(c&gt;<span class="number">2</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;<span class="number">2</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]==<span class="number">4</span>)&#123;c=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(x[i]!=c &amp;&amp; y[i]!=c) f[<span class="built_in">find</span>(x[i])]=<span class="built_in">find</span>(y[i]);</span><br><span class="line">    <span class="keyword">int</span> d=<span class="built_in">find</span>(c==<span class="number">1</span>?<span class="number">2</span>:<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(i!=c &amp;&amp; <span class="built_in">find</span>(i)!=d)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Rotation-Sort"><a href="#D-Rotation-Sort" class="headerlink" title="D. Rotation Sort"></a>D. Rotation Sort</h2><p>可以发现 $1$ 操作本质上是将一个数往右插，$2$ 就是把一个数往左插。</p>
<p>从左往右处理，考虑一个数如果向右插，等同于将其扔掉（直接计入答案）。所以考虑维护一个上升的序列表示没有向右插的集合。显然只要记录这个序列的最大值即可。</p>
<p>用 $f_{i,j}$ 表示前 $i$ 个数，上升序列最大值为 $j$ 的最小代价。</p>
<p>考虑新加数为 $x$，如果 $x&gt;j$ 那么可以向右插或者加入序列。如果 $x&lt;j$ 就只能向左插入序列。</p>
<p>复杂度 $O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x=<span class="built_in">min</span>(x,y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]&lt;j) <span class="built_in">chkmin</span>(f[i][j],f[i<span class="number">-1</span>][j]+b);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">chkmin</span>(f[i][j],f[i<span class="number">-1</span>][j]+a),<span class="built_in">chkmin</span>(f[i][p[i]],f[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    ll ans=<span class="number">1e16</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">min</span>(ans,f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Modulo-Pairing"><a href="#E-Modulo-Pairing" class="headerlink" title="E. Modulo Pairing"></a>E. Modulo Pairing</h2><p>显然只有两种可能：相加不超过 $M$ 与超过 $M$。</p>
<p>考虑先将原序列排序，可以证明，一定存在一个分界线，满足分界线左边右边各自首尾匹配。具体证明分类讨论一下即可。</p>
<p>右边部分显然要所有匹配 $&gt;m$，而右边和显然是单减的，所以可以二分。</p>
<p>总复杂度 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[N],n,m,ans=<span class="number">2e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">2</span>*x+<span class="number">2</span>*i&lt;=<span class="number">2</span>*n;i++) <span class="keyword">if</span>(a[<span class="number">2</span>*x+i]+a[<span class="number">2</span>*n-i+<span class="number">1</span>]&lt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++) res=<span class="built_in">max</span>(res,(a[i]+a[<span class="number">2</span>*x-i+<span class="number">1</span>])%m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">2</span>*x+<span class="number">2</span>*i&lt;=<span class="number">2</span>*n;i++) res=<span class="built_in">max</span>(res,(a[<span class="number">2</span>*x+i]+a[<span class="number">2</span>*n-i+<span class="number">1</span>])%m);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">2</span>*n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) <span class="built_in">upd</span>(mid),r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-One-Third"><a href="#F-One-Third" class="headerlink" title="F. One Third"></a>F. One Third</h2><p>考虑距离 $\frac 13$ 最近很难做，如果将序列每 $\frac 13$ 分成一块并且映射到一起，可以发现任意两个不同色的点之间距离就是到 $\frac 13$ 的距离。</p>
<p>这样转化为 $n$ 个点之间的不同色点距离最小值。</p>
<p>考虑一个式子：</p>
<p>$$<br>E(L_{k})=\frac 1n\left(\sum_{0&lt;i&lt;k}\frac 1{n-i}\right)<br>$$</p>
<p>其中 $L_{k}$ 表示第 $k$ 小的距离。具体证明可以用 min-max 容斥然后随便推一推。</p>
<p>这样枚举 $n$ 个点之间第 $k$ 对相邻点是第一对不同色点，那么前 $k$ 对一定是同色点，有：</p>
<p>$$<br>ans=\frac 1{3n}\sum_{i=1}^n\left(\frac{1}{3^{i-1}}-\frac{1}{3^i}\right)\sum_{j&lt;i}\frac1{n-i}<br>$$</p>
<p>直接处理即可，复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=<span class="number">1ll</span>*r*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _3[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    _3[<span class="number">1</span>]=<span class="built_in">ksm</span>(<span class="number">3</span>),_3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) _3[i]=<span class="number">1ll</span>*_3[i<span class="number">-1</span>]*_3[<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,res=<span class="built_in">ksm</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*(_3[i<span class="number">-1</span>]-_3[i])%mod*res)%mod;</span><br><span class="line">        res=(res+<span class="built_in">ksm</span>(n-i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*ans*<span class="built_in">ksm</span>(<span class="number">3</span>*n)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Grand Contest 055</title>
    <url>/2021/11/01/agc055/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+2}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{red}{\texttt{+}}$</td>
<td align="center">$\color{red}{\texttt{+2}}$</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://atcoder.jp/contests/agc055/tasks">链接</a></h2><p>下饭了，悲。</p>
<span id="more"></span>

<h2 id="A-ABC-Identity"><a href="#A-ABC-Identity" class="headerlink" title="A. ABC Identity"></a>A. ABC Identity</h2><details>
    <summary>题意</summary>

<p>给定一个 $ABC$ 构成的序列，将其分为 $6$ 个子序列，每段都是 $\text{A}^x\text{B}^x\text{C}^x$ 或 $\text{C}^x\text{A}^x\text{B}^x$ 或其他置换的形式。保证有解。</p>
</details>

<details>
    <summary>题解</summary>
    
<p>事实上手模一下可以发现只要 $A,B,C$ 数量相等一定有解。</p>
<p>考虑将序列分成 $3$ 段，每段长度为 $n$。每次贪心在第一段选择 $\text{A}$，第二段选择 $\text{B}$，第三段选择 $\text{C}$ 划成序列 $1$，然后选择 $\text{ACB}$ 划成序列 $2$，以此类推。</p>
<p>考虑证明为什么这样是对的：假设最后剩下了一些字符，不妨假设剩下了 $\text{CBA}$，那么这三个字符一定可以被贪心放入 $\text{CBA}$ 这个子序列中，其余同理。</p>
<p>所以一定可以构造出解。</p>
</details>

<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N],c[N][<span class="number">3</span>],n,m;</span><br><span class="line"><span class="keyword">bool</span> cut[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>,t3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!cut[i] &amp;&amp; a[i]==x) ++t1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) <span class="keyword">if</span>(!cut[i] &amp;&amp; a[i]==y) ++t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n*<span class="number">2</span>+<span class="number">1</span>;i&lt;=n*<span class="number">3</span>;i++) <span class="keyword">if</span>(!cut[i] &amp;&amp; a[i]==z) ++t3;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">min</span>(t1,<span class="built_in">min</span>(t2,t3));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=t;i++) <span class="keyword">if</span>(!cut[i] &amp;&amp; a[i]==x) cut[i]=<span class="literal">true</span>,ans[i]=id,j++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=t;i++) <span class="keyword">if</span>(!cut[i] &amp;&amp; a[i]==y) cut[i]=<span class="literal">true</span>,ans[i]=id,j++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n*<span class="number">2</span>+<span class="number">1</span>,j=<span class="number">1</span>;j&lt;=t;i++) <span class="keyword">if</span>(!cut[i] &amp;&amp; a[i]==z) cut[i]=<span class="literal">true</span>,ans[i]=id,j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);m=n*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) a[i]=s[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> id[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">solve</span>(id[<span class="number">0</span>],id[<span class="number">1</span>],id[<span class="number">2</span>],++t);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(id,id+<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="B-ABC-Supremacy"><a href="#B-ABC-Supremacy" class="headerlink" title="B. ABC Supremacy"></a>B. ABC Supremacy</h2><details>
    <summary>题意</summary>

<p>有两个长度为 $n$ 的 $ABC$ 序列 $s,t$，一次变换定义为将 $\text{ABC,BCA,CAB}$ 的其中一个变为另一个。问 $s$ 能否通过变换到达 $t$。</p>
<p>$|s|\leq 5\times 10^5$。</p>
</details>

<details>
    <summary>题解</summary>

<p>考虑令 $a_i=(s_i-\texttt{A}-i)\mod 3$。可以发现每次操作等价于将三个相邻相同的 $a_i$ 同时变成另一个 $[0,2]$ 的数字。</p>
<p>这样就是一个经典套路：考虑任意移动三个相邻且相同 $a_i$ 不会改变其余 $a_i$ 的相对顺序，所以可以认为这三个 $a_i$ 被删掉了。</p>
<p>容易发现，贪心删除之后，剩下序列要求全等。直接用一个栈模拟删除过程即可。复杂度 $O(n)$。</p>
</details>

<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[N],t[N];<span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span></span>&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">()</span></span>&#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[s[i]-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[t[i]-<span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">0</span>] || c[<span class="number">1</span>] || c[<span class="number">2</span>]) <span class="built_in">wrong</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_all</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(s[i]!=t[i]) <span class="built_in">wrong</span>();</span><br><span class="line">    <span class="built_in">right</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="keyword">bool</span> ca[N],cb[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n &amp;&amp; j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ca[i]) i++;</span><br><span class="line">        <span class="keyword">while</span>(cb[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[j]) <span class="built_in">wrong</span>();</span><br><span class="line">        i++,j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">right</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ton[N],tp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%s&quot;</span>,&amp;n,s+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">check_pre</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=(s[i]-<span class="string">&#x27;a&#x27;</span>-i%<span class="number">3</span>+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]=(t[i]-<span class="string">&#x27;a&#x27;</span>-i%<span class="number">3</span>+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(tp&gt;=<span class="number">2</span> &amp;&amp; a[i]==a[ton[tp]] &amp;&amp; a[i]==a[ton[tp<span class="number">-1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            ca[i]=ca[ton[tp]]=ca[ton[tp<span class="number">-1</span>]]=<span class="literal">true</span>;</span><br><span class="line">            tp-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ton[++tp]=i;</span><br><span class="line">    tp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(tp&gt;=<span class="number">2</span> &amp;&amp; b[i]==b[ton[tp]] &amp;&amp; b[i]==b[ton[tp<span class="number">-1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            cb[i]=cb[ton[tp]]=cb[ton[tp<span class="number">-1</span>]]=<span class="literal">true</span>;</span><br><span class="line">            tp-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ton[++tp]=i;</span><br><span class="line">    <span class="built_in">check</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Weird-LIS"><a href="#C-Weird-LIS" class="headerlink" title="C. Weird LIS"></a>C. Weird LIS</h2><details>
    <summary>题意</summary>

<p>问存在多少个长度为 $n$ 的 $a$ 数组满足：</p>
<ul>
<li>$a_i\in[2,m]$</li>
<li>存在长度为 $n$ 的排列 $P$，满足 $\forall i\in[1,n]\ ,\ P$ 删去 $P_i$ 后的最长上升子序列为 $a_i$。</li>
</ul>
<p>$n\leq 5000$。</p>
</details>

<details>
    <summary>题解</summary>

<p>首先 $a_i$ 的极差不超过 $1$。不妨假设 LIS 为 $X$，那么所有元素都是 $X$ 或 $X-1$。</p>
<p>思考什么情况下是合法的：因为 $X-1$ 必然在 LIS 中，不妨把 $X-1$ 的位置作为分界点，每个区域内部还可以互相匹配使 LIS $+1$。</p>
<p>可以发现的是，总有办法使值为 $X$ 的位置不在任何 LIS 中，对于剩下位置可以令其两两配对使 LIS $+1$。</p>
<p>换句话说，如果有 $a$ 个 $X-1$，$b$ 对互相配对的位置，最长上升子序列就是 $a+b$。</p>
<p>但是这样会记重。我们不妨规定：如果出现连续两个不在任何 LIS 中的位置，那么后面不能出现配对。</p>
<p>考虑 dp。令 $f_{i,j,0/1/2/3/4}$ 表示当前在 $i$，LIS 为 $j$，当前状态为 LIS上/需要配对/被配对/不在任何 LIS 中/不能出现配对。</p>
<p>互相转移即可。但是测一测样例会发现 <code>4 3</code> 的情况输出了 $8$，事实上因为当 $m=n-1$ 时全部为 $n-1$ 的情况，我们认为 LIS 为 $n$ 但事实上所有位置都是 $n-1$，需要特判（<del>然后赛时就在这里挂掉了</del>）。</p>
<p>复杂度 $O(n^2)$。</p>
</details>

<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,mod;</span><br><span class="line"><span class="keyword">int</span> f[N][N][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=(x+y&gt;=mod?x+y-mod:x+y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;mod);</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j) <span class="built_in">add</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j) <span class="built_in">add</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j) <span class="built_in">add</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">add</span>(f[i][j][<span class="number">1</span>],f[i<span class="number">-1</span>][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">add</span>(f[i][j][<span class="number">1</span>],f[i<span class="number">-1</span>][j][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j) <span class="built_in">add</span>(f[i][j][<span class="number">2</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">add</span>(f[i][j][<span class="number">3</span>],f[i<span class="number">-1</span>][j][<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">add</span>(f[i][j][<span class="number">3</span>],f[i<span class="number">-1</span>][j][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">add</span>(f[i][j][<span class="number">4</span>],f[i<span class="number">-1</span>][j][<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">add</span>(f[i][j][<span class="number">4</span>],f[i<span class="number">-1</span>][j][<span class="number">4</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j) <span class="built_in">add</span>(f[i][j][<span class="number">4</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d:&quot;,i,j);</span></span><br><span class="line">            <span class="comment">// for(int k=0;k&lt;5;k++) printf(&quot;%d &quot;,f[i][j][k]);</span></span><br><span class="line">            <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">add</span>(ans,f[n][i][<span class="number">0</span>]),</span><br><span class="line">        <span class="built_in">add</span>(ans,f[n][i][<span class="number">2</span>]),</span><br><span class="line">        <span class="built_in">add</span>(ans,f[n][i][<span class="number">3</span>]),</span><br><span class="line">        <span class="built_in">add</span>(ans,f[n][i][<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">if</span>(n==m+<span class="number">1</span>) ans=(ans+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="D-ABC-Ultimatum"><a href="#D-ABC-Ultimatum" class="headerlink" title="D. ABC Ultimatum"></a>D. ABC Ultimatum</h2><details>
    <summary>题意</summary>

<p>定义一个长度为 $3n$ 的字符串 $S$ 是好的，当且仅当 $S$ 可以被分解为 $n$ 个子序列，每个子序列都是 $\text{ABC,BCA,CAB}$ 中的一个。</p>
<p>给定一个 $3n$ 的残缺字符串（带有 <code>?</code>），问有多少个字符串是好的。$n\leq 15$。</p>
</details>

<details>
    <summary>题解</summary>

<p>令 $F_{\text{AB}}(i)$ 表示将前 $i$ 个字符中的 $\text{A}$ 的数量减去 $\text{B}$ 的数量。令 $M_{\text{AB}}=\max{F_{\text{AB}}(i)}$。同理定义 $M_{\text{BC}}$ 和 $M_{\text{CA}}$。</p>
<p><strong>结论</strong>：$S$ 合法当且仅当 $M_{\text{AB}}+M_{\text{BC}}+M_{\text{CA}}\leq n$，且 $\text{A,B,C}$ 数量均为 $n$。</p>
<p><strong>必要性</strong>：对于合法的分裂，显然 $M_{\text{AB}}$ 不超过 $\text{BCA}$ 个数，$M_{\text{BC}}$ 不超过 $\text{CAB}$ 个数，$\text{CA}$ 同理。故对于合法的 $S$ 一定有 $M_{\text{AB}}+M_{\text{BC}}+M_{\text{CA}}\leq n$。</p>
<p><strong>充分性</strong>：考虑维护三个指针。初始分别指向：第 $1$ 个 $\text{A}$，第 $1+M_\text{AB}$ 个 $\text{B}$，第 $1+M_\text{AB}+M_\text{BC}$ 个 $\text{C}$。不断匹配然后右移指针，移到最后就循环到开头。因为 $\text{A}$ 至多向后偏移 $\text{AB}$，所以 $\text{A}$ 的指针和 $\text{B}$ 不会相撞。$\text{B,C}$ 同理。由于 $M_{\text{AB}}+M_{\text{BC}}+M_{\text{CA}}\leq n$，所以最后 $\text{C,A}$ 也不会相撞。所以构造合法。</p>
<p>直接 dp，令 $f_{i,ab,bc,ca,a,b,c}$ 表示前 $i$ 个数中，$M_{\text{AB}},M_{\text{BC}},M_{\text{CA}}$ 数量，$\text{A,B,C}$ 数量。直接转移 $O(n^7)$。</p>
<p>可以发现 $c=i-a-b$，可以省掉一维。复杂度 $O(n^6)$。</p>
</details>

<details>
    <summary>代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N][N][N][N][N],g[N][N][N][N][N];</span><br><span class="line"><span class="keyword">char</span> s[N*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">char</span> c)</span></span>&#123;<span class="keyword">return</span> s[x]==c || s[x]==<span class="string">&#x27;?&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span></span>&#123;x=(x+y&gt;=mod?x+y-mod:x+y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=n*<span class="number">3</span>;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(f,g,<span class="built_in"><span class="keyword">sizeof</span></span>(f));<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ab=<span class="number">0</span>;ab&lt;=n;ab++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bc=<span class="number">0</span>;bc&lt;=n;bc++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ca=<span class="number">0</span>;ca&lt;=n;ca++)</span><br><span class="line">        <span class="keyword">if</span>(ab+bc+ca&lt;=n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;=n;a++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;=n;b++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> dab=<span class="built_in">max</span>(ab<span class="number">-1</span>,<span class="number">0</span>),dbc=<span class="built_in">max</span>(bc<span class="number">-1</span>,<span class="number">0</span>),dca=<span class="built_in">max</span>(ca<span class="number">-1</span>,<span class="number">0</span>),u=f[ab][bc][ca][a][b];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(i,<span class="string">&#x27;A&#x27;</span>)) <span class="built_in">add</span>(g[dab][bc+<span class="number">1</span>][ca][a+<span class="number">1</span>][b],u);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(i,<span class="string">&#x27;B&#x27;</span>)) <span class="built_in">add</span>(g[ab][dbc][ca+<span class="number">1</span>][a][b+<span class="number">1</span>],u);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(i,<span class="string">&#x27;C&#x27;</span>)) <span class="built_in">add</span>(g[ab+<span class="number">1</span>][bc][dca][a][b],u);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ab=<span class="number">0</span>;ab&lt;=n;ab++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> bc=<span class="number">0</span>;bc&lt;=n;bc++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ca=<span class="number">0</span>;ca&lt;=n;ca++)</span><br><span class="line">    <span class="keyword">if</span>(ab+bc+ca&lt;=n) <span class="built_in">add</span>(res,g[ab][bc][ca][n][n]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Atcoder Regular Contest 058 ~ 062</title>
    <url>/2021/02/27/arc058-062/</url>
    <content><![CDATA[<p>arc058-062</p>
<span id="more"></span>
<h2 id="AtCoder-Regular-Contest-058"><a href="#AtCoder-Regular-Contest-058" class="headerlink" title="AtCoder Regular Contest 058"></a><a href="https://atcoder.jp/contests/arc058">AtCoder Regular Contest 058</a></h2><h3 id="E-Iroha-and-Haiku"><a href="#E-Iroha-and-Haiku" class="headerlink" title="E. Iroha and Haiku"></a>E. Iroha and Haiku</h3><p>考虑 $X+Y+Z$ 很小，所以想办法把一个有序数列状态压缩。</p>
<p>一种想法是求出原序列的后缀和，然后压后缀和的每个元素。显然我们可以通过后缀和推出一个唯一的序列。</p>
<p>包含 $X,Y,Z$ 就等价于该序列后缀和是原序列的子序列。</p>
<p>最后发现可行方案不是很好做，处理不可行然后容斥即可。复杂度 $O(n2^n)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">1</span>&lt;&lt;M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,y,z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;x,&amp;y,&amp;z);</span><br><span class="line">    <span class="keyword">int</span> m=x+y+z,sm=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> o=(<span class="number">1</span>&lt;&lt;(z<span class="number">-1</span>))|(<span class="number">1</span>&lt;&lt;(y+z<span class="number">-1</span>))|(<span class="number">1</span>&lt;&lt;(x+y+z<span class="number">-1</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)<span class="comment">//a_i=j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=sm;s++)<span class="comment">//the set of suf-sum</span></span><br><span class="line">            <span class="keyword">if</span>(f[i<span class="number">-1</span>][s])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=((s&lt;&lt;j)|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&amp;sm;</span><br><span class="line">                <span class="keyword">if</span>((t&amp;o)==o) <span class="keyword">continue</span>;</span><br><span class="line">                f[i][t]=(f[i][t]+f[i<span class="number">-1</span>][s])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="number">10ll</span>*ans%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;=sm;s++) ans=(ans-f[n][s]+mod)%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Iroha-Loves-Strings"><a href="#F-Iroha-Loves-Strings" class="headerlink" title="F. Iroha Loves Strings"></a>F. Iroha Loves Strings</h3><p>做法1：首先存下到每个点为之长度为 $i$ 的最小的字符串，然后暴力转移，就可以得到一个 $O(nk^2+nm)$ 的做法，但是不太行。</p>
<p>考虑优化：可以发现这个做法最大的问题在于存下了所有的长度的字符串。但事实上有一些字符串不可能成为最大值。</p>
<p>首先我们先 $O(nK)$ 大力背包预处理可以快速算出从某个点开始可不可行。这样对于点 $i$，如果一个长度为 $i$ 的字符串严格大于长度为 $j$ 的字符串（即字典序大于且不是前后缀关系）且均有解，那么 $i$ 一定不会成为最值。换句话说，所有可能成为最值的字符串均是一个最长字符串的前缀。</p>
<p>这样我们维护一个单调栈，使用 SA + ST 表预处理即可达到 $O(nk+M)$ 的复杂度。</p>
<p>做法2：考虑我们将题目转化为：给定一个字符串和若干关键点，每次到某一个关键点就可以跳到后面的任何一个。求走恰好 $k$ 步的最小字符串。</p>
<p>那么一个显然的想法就是：如果可以走，就贪心往最小的走。</p>
<p>用 bitset 压可以转移的位置和某字符集合的位置集合，暴力转移。</p>
<p>复杂度 $O(nk+\frac{nm\log C}{\omega})$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 10010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[M];<span class="keyword">int</span> p[N],len[N];</span><br><span class="line">bitset&lt;K&gt;f[N];</span><br><span class="line">bitset&lt;M&gt;g[<span class="number">65</span>],w;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+p[i]);</span><br><span class="line">		len[i]=<span class="built_in">strlen</span>(s+p[i]);</span><br><span class="line">		p[i+<span class="number">1</span>]=p[i]+len[i];</span><br><span class="line">	&#125;</span><br><span class="line">	f[n+<span class="number">1</span>].<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) f[i]=f[i+<span class="number">1</span>]|(f[i+<span class="number">1</span>]&lt;&lt;len[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p[n+<span class="number">1</span>];i++) g[<span class="number">32</span>+s[i]-<span class="string">&#x27;a&#x27;</span>].<span class="built_in">set</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i;i--) g[i]=g[i&lt;&lt;<span class="number">1</span>]|g[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">	w.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u;i&lt;=k;i++,w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		<span class="keyword">if</span>(w.<span class="built_in">test</span>(p[j])) w.<span class="built_in">set</span>(p[j+<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(i+len[j]<span class="number">-1</span>&gt;k || !f[j+<span class="number">1</span>].<span class="built_in">test</span>(k-i-len[j]+<span class="number">1</span>)) w.<span class="built_in">set</span>(p[j],<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(u=<span class="number">1</span>;u&lt;<span class="number">32</span>;u=u&lt;&lt;<span class="number">1</span>|!(g[u&lt;&lt;<span class="number">1</span>]&amp;w).<span class="built_in">any</span>());</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>+u<span class="number">-32</span>); w&amp;=g[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-059"><a href="#AtCoder-Regular-Contest-059" class="headerlink" title="AtCoder Regular Contest 059"></a><a href="https://atcoder.jp/contests/arc059">AtCoder Regular Contest 059</a></h2><h3 id="E-Children-and-Candies"><a href="#E-Children-and-Candies" class="headerlink" title="E. Children and Candies"></a>E. Children and Candies</h3><p>水题。首先 $x_i$ 的具体值对答案的影响是独立的。</p>
<p>考虑交换求和/求积顺序后，令 $f_{i,j}$ 表示 $i$ 位置分配了 $j$，之前的所有和。</p>
<p>有 $f_{i,j}=\sum_{j\leq i}\left(f_{i-1,k}\sum_{p=a_i}^{b_i}{p^{j-k}}\right)$。</p>
<p>随便前缀和一下就 $O(n^3)$ 了。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 410</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N][N],sm[N][N];<span class="comment">//\sum_j&#123;j^i&#125;</span></span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-10</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=sm[<span class="number">0</span>][i]=<span class="number">1</span>;j&lt;=N<span class="number">-10</span>;j++)</span><br><span class="line">			sm[j][i]=<span class="number">1ll</span>*sm[j<span class="number">-1</span>][i]*i%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N<span class="number">-10</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N<span class="number">-10</span>;j++)</span><br><span class="line">			sm[i][j]=(sm[i][j]+sm[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j;k++)</span><br><span class="line">			f[i][j]=(f[i][j]+<span class="number">1ll</span>*f[i<span class="number">-1</span>][k]*(sm[j-k][b[i]]-sm[j-k][a[i]<span class="number">-1</span>]+mod))%mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n][m]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Unhappy-Hacking"><a href="#F-Unhappy-Hacking" class="headerlink" title="F. Unhappy Hacking"></a>F. Unhappy Hacking</h3><p>以为是一道神仙题，结果是道脑筋急转弯题。</p>
<p>注意到按 $0,1$ 其实是本质相同的，也就是说长度相同的任意字符串出现的方案数相同。</p>
<p>所以直接算出长度为 $m$ 的字符串出现方案数即可。</p>
<p>设 $f_{i,j}$ 表示按了 $I$ 下，长度为 $j$ 的方案数。显然有 $f_{i,j}\rightarrow f_{i+1,\max(j-1,0),f_{i+1,j+1}}$。</p>
<p>复杂度 $O(n^2)$。</p>
<details>
    <summary>查看代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N][N];<span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=<span class="number">1ll</span>*r*a%mod;</span><br><span class="line">		a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> m=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			(f[i][<span class="built_in">max</span>(j<span class="number">-1</span>,<span class="number">0</span>)]+=f[i<span class="number">-1</span>][j])%=mod;</span><br><span class="line">			f[i][j+<span class="number">1</span>]=(f[i][j+<span class="number">1</span>]+<span class="number">2ll</span>*f[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">1ll</span>*f[n][m]*<span class="built_in">ksm</span>(<span class="built_in">ksm</span>(<span class="number">2</span>,m))%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-060"><a href="#AtCoder-Regular-Contest-060" class="headerlink" title="AtCoder Regular Contest 060"></a><a href="https://atcoder.jp/contests/arc060">AtCoder Regular Contest 060</a></h2><h3 id="E-Tak-and-Hotels"><a href="#E-Tak-and-Hotels" class="headerlink" title="E. Tak and Hotels"></a>E. Tak and Hotels</h3><p>$\color{red}{skipped}$</p>
<h3 id="F-Best-Representation"><a href="#F-Best-Representation" class="headerlink" title="F. Best Representation"></a>F. Best Representation</h3><p>第一眼幻视成串串划分，结果发现是神必题。</p>
<p>考虑给定的字符串如果不是全部相等，那么要么原来的串不是一个循环串，要么去掉首字母后不是一个循环串。所以答案至多为 $2$。</p>
<p>判掉 $1$ 和 $n$ 的情况之后，剩下的就变成询问从某个点分开左右是不是循环串。</p>
<p>这个直接枚举循环节然后打标记即可。复杂度 $O(n\log n)$。</p>
<details>
    <summary>查看代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1019260817</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> hs[N],bs[N];<span class="keyword">const</span> <span class="keyword">int</span> B=<span class="number">233</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> (hs[r]<span class="number">-1ll</span>*hs[l<span class="number">-1</span>]*bs[r-l+<span class="number">1</span>]%mod+mod)%mod;&#125;</span><br><span class="line"><span class="keyword">bool</span> ban[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=bs[<span class="number">0</span>]=<span class="number">1</span>;i&lt;=n;i++) hs[i]=(<span class="number">1ll</span>*hs[i<span class="number">-1</span>]*B+(s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>))%mod,bs[i]=<span class="number">1ll</span>*bs[i<span class="number">-1</span>]*B%mod;</span><br><span class="line">	<span class="keyword">bool</span> same=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>]) same=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(same)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n1&quot;</span>,n);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j+i&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>(<span class="number">1</span>,i)==<span class="built_in">get</span>(i*j+<span class="number">1</span>,i*j+i)) ban[i*j+i]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j+i&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>(n-i+<span class="number">1</span>,n)==<span class="built_in">get</span>(n-i*j-i+<span class="number">1</span>,n-i*j)) ban[n-i*j-i]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!ban[n])&#123;<span class="built_in">puts</span>(<span class="string">&quot;1\n1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	<span class="keyword">if</span>(!ban[i]) c++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2\n%d\n&quot;</span>,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-061"><a href="#AtCoder-Regular-Contest-061" class="headerlink" title="AtCoder Regular Contest 061"></a><a href="https://atcoder.jp/contests/arc061">AtCoder Regular Contest 061</a></h2><h3 id="E-Snuke’s-Subway-Trip"><a href="#E-Snuke’s-Subway-Trip" class="headerlink" title="E. Snuke’s Subway Trip"></a>E. Snuke’s Subway Trip</h3><p>考虑把每个可以直接到达的点之间建一个新点，向该颜色联通块中的点连一条无向边。</p>
<p>容易发现新图中的最短路就是答案的两倍。</p>
<details>
    <summary>查看代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">2</span>],to[N&lt;&lt;<span class="number">2</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cnt]=head[u];</span><br><span class="line">	to[cnt]=v;head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==f[x]?f[x]:(f[x]=<span class="built_in">find</span>(f[x]));&#125;</span><br><span class="line">vector&lt;P &gt;g[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[N],tt;</span><br><span class="line"><span class="keyword">int</span> idn=<span class="number">0</span>,id[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(s);vis[s]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=to[i];</span><br><span class="line">			<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[v]=<span class="literal">true</span>;dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !vis[t]?<span class="number">-1</span>:dis[t]/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		g[w].<span class="built_in">push_back</span>(<span class="built_in">MP</span>(u,v));mx=<span class="built_in">max</span>(mx,w);</span><br><span class="line">	&#125;</span><br><span class="line">	idn=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;i++)</span><br><span class="line">	<span class="keyword">if</span>(!g[i].<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		tt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(P u:g[i])</span><br><span class="line">		&#123;</span><br><span class="line">			tmp[++tt]=u.fi;tmp[++tt]=u.se;</span><br><span class="line">			f[<span class="built_in">find</span>(u.fi)]=<span class="built_in">find</span>(u.se);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tt;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u=tmp[j];<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(!id[<span class="built_in">find</span>(u)]) id[<span class="built_in">find</span>(u)]=++idn;</span><br><span class="line">			id[u]=id[<span class="built_in">find</span>(u)];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tt;j++) vis[tmp[j]]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tt;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> u=tmp[j];<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[u]=<span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">add</span>(u,id[u]),<span class="built_in">add</span>(id[u],u);</span><br><span class="line">			<span class="comment">//printf(&quot;add %d %d\n&quot;,u,id[u]);</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tt;j++) vis[tmp[j]]=id[tmp[j]]=<span class="number">0</span>,f[tmp[j]]=tmp[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">bfs</span>(<span class="number">1</span>,n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Card-Game-for-Three"><a href="#F-Card-Game-for-Three" class="headerlink" title="F. Card Game for Three"></a>F. Card Game for Three</h3><p>考虑 $A$ 要获胜必须在某一时刻拿出了 $n$ 张 $A$，且 $B,C$ 分别不超过 $m,k$。</p>
<p>那么就有答案等于 $\displaystyle\sum_{i=n}^{s}\binom{i}{n}3^{s-i}\sum_{j=i-n-k}^m\binom{i-n}{j}$。</p>
<p>枚举 $i$，发现后面那个式子可以递推处理。复杂度 $O(n)$。</p>
<details>
    <summary>查看代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=<span class="number">1ll</span>*r*a%mod;</span><br><span class="line">        a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b || a&lt;<span class="number">0</span> || b&lt;<span class="number">0</span>?<span class="number">0</span>:<span class="number">1ll</span>*fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n=N<span class="number">-10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">ksm</span>(fac[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=<span class="number">1ll</span>*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _3[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> s=n+m+k,ans=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;k) <span class="built_in">swap</span>(m,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=_3[<span class="number">0</span>]=<span class="number">1</span>;i&lt;=s;i++) _3[i]=_3[i<span class="number">-1</span>]*<span class="number">3ll</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m+k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*r*<span class="built_in">C</span>(n+i<span class="number">-1</span>,n<span class="number">-1</span>)%mod*_3[m+k-i]%mod)%mod;</span><br><span class="line">        r=(r*<span class="number">2ll</span>-<span class="built_in">C</span>(i,k)-<span class="built_in">C</span>(i,i-m)+<span class="number">2ll</span>*mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-062"><a href="#AtCoder-Regular-Contest-062" class="headerlink" title="AtCoder Regular Contest 062"></a><a href="https://atcoder.jp/contests/arc062">AtCoder Regular Contest 062</a></h2><h3 id="E-Building-Cubes-with-AtCoDeer"><a href="#E-Building-Cubes-with-AtCoDeer" class="headerlink" title="E. Building Cubes with AtCoDeer"></a>E. Building Cubes with AtCoDeer</h3><p>考虑枚举上顶面和下底面，那么剩下的四个面就是确定的。</p>
<p>用一个 $\text{map}$ 记录下每种面旋转同构后的结果，注意每取一个就要删除该元素以免计重。</p>
<p>复杂度 $O(n^2\log n)$。</p>
<details>
    <summary>查看代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 410</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>,<span class="keyword">int</span> d=<span class="number">0</span>)&#123;p[<span class="number">0</span>]=a;p[<span class="number">1</span>]=b;p[<span class="number">2</span>]=c;p[<span class="number">3</span>]=d;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rot</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) <span class="built_in">swap</span>(p[i],p[i+<span class="number">1</span>]);&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a,<span class="keyword">const</span> node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;<span class="number">4</span>;t++)</span><br><span class="line">        <span class="keyword">if</span>(a.p[t]!=b.p[t]) <span class="keyword">return</span> a.p[t]&lt;b.p[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> &lt;&lt;(node a,<span class="keyword">int</span> p)&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p%<span class="number">4</span>;i++) a.<span class="built_in">rot</span>();<span class="keyword">return</span> a;&#125;</span><br><span class="line">node <span class="keyword">operator</span> |(node a,node b)&#123;<span class="keyword">return</span> <span class="built_in">node</span>(a.p[<span class="number">1</span>],a.p[<span class="number">0</span>],b.p[<span class="number">0</span>],b.p[<span class="number">3</span>]);&#125;</span><br><span class="line"><span class="function">vector&lt;node&gt; <span class="title">all_node</span><span class="params">(node a)</span></span>&#123;<span class="keyword">return</span> &#123;a,a&lt;&lt;<span class="number">1</span>,a&lt;&lt;<span class="number">2</span>,a&lt;&lt;<span class="number">3</span>&#125;;&#125;</span><br><span class="line">map&lt;node,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(node u,<span class="keyword">int</span> v)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> p:<span class="built_in">all_node</span>(u)) mp[p]+=v;&#125;</span><br><span class="line">node sw[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a[i].p[<span class="number">0</span>],&amp;a[i].p[<span class="number">1</span>],&amp;a[i].p[<span class="number">2</span>],&amp;a[i].p[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">ins</span>(a[i],<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ins</span>(a[i],<span class="number">-1</span>);node u=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ins</span>(a[j],<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:<span class="built_in">all_node</span>(a[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++,u=u&lt;&lt;<span class="number">1</span>,v=v&lt;&lt;<span class="number">3</span>) sw[k]=u|v;</span><br><span class="line">                <span class="keyword">bool</span> can=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span> &amp;&amp; can;k++)</span><br><span class="line">                <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(sw[k])) can=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!can) <span class="keyword">continue</span>;</span><br><span class="line">                ll res=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) res*=mp[sw[k]],<span class="built_in">ins</span>(sw[k],<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) <span class="built_in">ins</span>(sw[k],<span class="number">1</span>);</span><br><span class="line">                ans+=res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ins</span>(a[j],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Painting-Graphs-with-AtCoDeer"><a href="#F-Painting-Graphs-with-AtCoDeer" class="headerlink" title="F. Painting Graphs with AtCoDeer"></a>F. Painting Graphs with AtCoDeer</h3><p>考虑如果给定的是一棵树，那么一定不存在同构情况。</p>
<p>而如果给定的是一个环，这显然就是 $Polya$ 定理。</p>
<p>如果给定的是环加上若干条边，可以证明的是任意两条边都可以互换。</p>
<p>所以缩一个点双，然后判断每个点双：如果只有两个点直接乘 $k$，否则判断是那种情况。</p>
<p>由于 $n$ 只有 $50$，随便怎么搞都行。</p>
<details>
    <summary>查看代码</summary>
    
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cnt]=head[u];</span><br><span class="line">	to[cnt]=v;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;bc[N];<span class="keyword">int</span> bt;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],idn;</span><br><span class="line"><span class="keyword">int</span> st[N],tp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++idn;</span><br><span class="line">	st[++tp]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">			<span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">			&#123;</span><br><span class="line">				++bt;</span><br><span class="line">				<span class="keyword">while</span>(st[tp]!=v) bc[bt].<span class="built_in">push_back</span>(st[tp--]);</span><br><span class="line">				bc[bt].<span class="built_in">push_back</span>(st[tp--]);bc[bt].<span class="built_in">push_back</span>(u);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(v!=p) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=<span class="number">1ll</span>*r*a%mod;</span><br><span class="line">		a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*fac[x]*inv[y]%mod*inv[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n=N<span class="number">-10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">ksm</span>(fac[n]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=<span class="number">1ll</span>*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y==<span class="number">0</span>?x:<span class="built_in">gcd</span>(y,x%y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=bt;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> rd=<span class="number">0</span>,pn=bc[p].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span>(pn==<span class="number">2</span>)&#123;ans=<span class="number">1ll</span>*ans*k%mod;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u:bc[p]) vis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u:bc[p])</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">			<span class="keyword">if</span>(to[i]&gt;u &amp;&amp; vis[to[i]]) rd++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> u:bc[p]) vis[u]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(pn==rd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=pn;i++) res=(res+<span class="built_in">ksm</span>(k,<span class="built_in">gcd</span>(i,pn)))%mod;</span><br><span class="line">			res=<span class="number">1ll</span>*res*<span class="built_in">ksm</span>(pn)%mod;</span><br><span class="line">			ans=<span class="number">1ll</span>*ans*res%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans=<span class="number">1ll</span>*ans*<span class="built_in">C</span>(rd+k<span class="number">-1</span>,k<span class="number">-1</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 063 ~ 067</title>
    <url>/2021/02/27/arc063-067/</url>
    <content><![CDATA[<p>arc063-067</p>
<span id="more"></span>
<h2 id="AtCoder-Regular-Contest-063"><a href="#AtCoder-Regular-Contest-063" class="headerlink" title="AtCoder Regular Contest 063"></a><a href="https://atcoder.jp/contests/arc063">AtCoder Regular Contest 063</a></h2><h3 id="E-Integers-on-a-Tree"><a href="#E-Integers-on-a-Tree" class="headerlink" title="E. Integers on a Tree"></a>E. Integers on a Tree</h3><p>构造题。一般这种二选一都是先钦定一种，再改成另一种。我们不妨假设所有儿子权值都是父节点 $+1$。</p>
<p>这样我们钦定父节点是儿子中权值最大的点 $-1$。如果父节点有值且比这个权值小那么直接无解。</p>
<p>然后考虑从上到下，如果一个子节点小于父节点 $-1$ 那么改成父节点 $-1$。如果不合法就无解。</p>
<p>复杂度 $O(n)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cnt]=head[u];</span><br><span class="line">	to[cnt]=v;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> w[N],val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==p) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		val[u]=<span class="built_in">max</span>(val[u],val[v]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(w[u]&gt;-inf &amp;&amp; val[u]&gt;w[u])&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">	val[u]=<span class="built_in">max</span>(val[u],w[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(w[u]&gt;-inf &amp;&amp; w[u]!=val[u])&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v=to[i];</span><br><span class="line">		<span class="keyword">if</span>(v==p) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(val[v]!=val[u]+<span class="number">1</span> &amp;&amp; val[v]!=val[u]<span class="number">-1</span>) val[v]=val[u]<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,q;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) w[i]=val[i]=-inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">while</span>(q --&gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;v);</span><br><span class="line">		w[x]=v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Snuke’s-Coloring-2"><a href="#F-Snuke’s-Coloring-2" class="headerlink" title="F. Snuke’s Coloring 2"></a>F. Snuke’s Coloring 2</h3><p>首先考虑答案一定可以达到 $2\max(n,m)+2$ 级别。换句话说要么经过 $x$ 中线，要么经过 $y$ 中线。</p>
<p>不妨假设经过 $x$ 中线。按照套路我们假设一个必经的 $y$ 线，然后对于每个位置我们可以处理出其左右最远延伸的位置。</p>
<p>由于 $x$ 和 $y$ 是线性相加的，所以可以直接单调队列 + 双指针维护最大值。</p>
<p>注意我们双指针的其实是左端点较小值，单调队列的是右端点的较小值。所以对于左端点上下两块作为最小值的情况都要做一遍。</p>
<p>复杂度 $O(n\log n)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x&lt;a.x;&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">int</span> lf[N],rf[N],n,m,k,mx;</span><br><span class="line"><span class="keyword">int</span> q[N],ql,qr,ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(l,mid);<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	lf[mid]=lf[mid+<span class="number">1</span>]=<span class="number">0</span>,rf[mid]=rf[mid+<span class="number">1</span>]=m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=mid<span class="number">-1</span>;i&gt;=l;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		lf[i]=lf[i+<span class="number">1</span>];rf[i]=rf[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(p[i+<span class="number">1</span>].y&lt;=mx) lf[i]=<span class="built_in">max</span>(lf[i],p[i+<span class="number">1</span>].y);</span><br><span class="line">		<span class="keyword">if</span>(p[i+<span class="number">1</span>].y&gt;=mx) rf[i]=<span class="built_in">min</span>(rf[i],p[i+<span class="number">1</span>].y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		lf[i]=lf[i<span class="number">-1</span>];rf[i]=rf[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(p[i<span class="number">-1</span>].y&lt;=mx) lf[i]=<span class="built_in">max</span>(lf[i],p[i<span class="number">-1</span>].y);</span><br><span class="line">		<span class="keyword">if</span>(p[i<span class="number">-1</span>].y&gt;=mx) rf[i]=<span class="built_in">min</span>(rf[i],p[i<span class="number">-1</span>].y);</span><br><span class="line">	&#125;</span><br><span class="line">	ql=<span class="number">1</span>,qr=<span class="number">0</span>;<span class="keyword">int</span> tr=mid+<span class="number">1</span>,tl=mid;</span><br><span class="line">	<span class="keyword">for</span>(;tl&gt;=l;tl--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;tr&lt;=r &amp;&amp; lf[tr]&lt;=lf[tl];q[++qr]=tr++)</span><br><span class="line">			<span class="keyword">for</span>(;ql&lt;=qr &amp;&amp; rf[q[qr]]+p[q[qr]].x&lt;=rf[tr]+p[tr].x;qr--);</span><br><span class="line">		<span class="keyword">for</span>(;ql&lt;qr &amp;&amp; rf[tl]+p[q[ql]].x&lt;=rf[q[ql+<span class="number">1</span>]]+p[q[ql+<span class="number">1</span>]].x;ql++);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,p[q[ql]].x-p[tl].x+<span class="built_in">min</span>(rf[tl],rf[q[ql]])-lf[tl]);</span><br><span class="line">	&#125;</span><br><span class="line">	ql=<span class="number">1</span>,qr=<span class="number">0</span>;tr=mid+<span class="number">1</span>,tl=mid;</span><br><span class="line">	<span class="keyword">for</span>(;tr&lt;=r;tr++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;tl&gt;=l &amp;&amp; lf[tl]&lt;=lf[tr];q[++qr]=tl--)</span><br><span class="line">			<span class="keyword">for</span>(;ql&lt;=qr &amp;&amp; rf[q[qr]]-p[q[qr]].x&lt;=rf[tl]-p[tl].x;qr--);</span><br><span class="line">		<span class="keyword">for</span>(;ql&lt;qr &amp;&amp; rf[tr]-p[q[ql]].x&lt;=rf[q[ql+<span class="number">1</span>]]-p[q[ql+<span class="number">1</span>]].x;ql++);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,p[tr].x-p[q[ql]].x+<span class="built_in">min</span>(rf[tr],rf[q[ql]])-lf[tr]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+k+<span class="number">1</span>);mx=m/<span class="number">2</span>;</span><br><span class="line">	p[<span class="number">0</span>]=(node)&#123;<span class="number">0</span>,mx&#125;;</span><br><span class="line">	p[k+<span class="number">1</span>]=(node)&#123;n,mx&#125;;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">0</span>,k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">	ans=<span class="built_in">max</span>(n,m)+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">make</span>();</span><br><span class="line">	<span class="built_in">swap</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">swap</span>(p[i].x,p[i].y);</span><br><span class="line">	<span class="built_in">make</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans*<span class="number">2ll</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-064"><a href="#AtCoder-Regular-Contest-064" class="headerlink" title="AtCoder Regular Contest 064"></a><a href="https://atcoder.jp/contests/arc064">AtCoder Regular Contest 064</a></h2><h3 id="E-Cosmic-Rays"><a href="#E-Cosmic-Rays" class="headerlink" title="E. Cosmic Rays"></a>E. Cosmic Rays</h3><p>大水题。直接处理两两之间的最短路，用不带优化的 $dijkstra$。复杂度 $O(n^2)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e17</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cir</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,r;</span><br><span class="line">&#125;c[N],s,t;</span><br><span class="line"><span class="function">db <span class="title">dist</span><span class="params">(cir a,cir b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">sqrt</span>(<span class="number">1.0</span>*(a.x-b.x)*(a.x-b.x)+<span class="number">1.0</span>*(a.y-b.y)*(a.y-b.y))-a.r-b.r,<span class="number">0.0</span>);&#125;</span><br><span class="line">db dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;s.x,&amp;s.y,&amp;t.x,&amp;t.y);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;c[i].x,&amp;c[i].y,&amp;c[i].r);</span><br><span class="line">	c[++n]=t;c[<span class="number">0</span>]=s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="built_in">dist</span>(c[i],s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(!vis[j] &amp;&amp; (!u || dis[u]&gt;dis[j])) u=j;</span><br><span class="line">		vis[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(!vis[j]) dis[j]=<span class="built_in">min</span>(dis[j],dis[u]+<span class="built_in">dist</span>(c[u],c[j]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>,dis[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Rotated-Palindromes"><a href="#F-Rotated-Palindromes" class="headerlink" title="F. Rotated Palindromes"></a>F. Rotated Palindromes</h3><p>首先定义 $f_i$ 表示长度为 $i$ 且没有循环节的回文串个数。</p>
<p>容斥一下显然有</p>
<p>$$f_i=K^{\lceil\frac i2\rceil}-\sum_{d|i}f_d$$<br>$$\text{ans}=\sum_{i|n}f_i\times\frac i{1+[i\text{ is even}]}$$</p>
<p>可以发现这个式子严格不强于杜教筛的那个式子，故直接记忆化搜索复杂度 $O(n^{\frac 34})$，实际跑不满。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=<span class="number">1ll</span>*r*a%mod;</span><br><span class="line">		a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> k;</span><br><span class="line">	<span class="keyword">if</span>(f.<span class="built_in">count</span>(x)) <span class="keyword">return</span> f[x];</span><br><span class="line">	<span class="keyword">int</span> res=<span class="built_in">ksm</span>(k,(x+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">1ll</span>*i*i&lt;=x;i++)</span><br><span class="line">	<span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		res=(res-<span class="built_in">calc</span>(i)+mod)%mod;</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">1</span> &amp;&amp; i*i!=x) res=(res-<span class="built_in">calc</span>(x/i)+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[x]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">1ll</span>*i*i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=(ans+<span class="number">1ll</span>*<span class="built_in">calc</span>(i)*(i%<span class="number">2</span>?i:i/<span class="number">2</span>))%mod;</span><br><span class="line">		<span class="keyword">if</span>(i*i!=n) ans=(ans+<span class="number">1ll</span>*<span class="built_in">calc</span>(n/i)*((n/i)%<span class="number">2</span>?(n/i):(n/i/<span class="number">2</span>)))%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-065"><a href="#AtCoder-Regular-Contest-065" class="headerlink" title="AtCoder Regular Contest 065"></a><a href="https://atcoder.jp/contests/arc065">AtCoder Regular Contest 065</a></h2><h3 id="E-Manhattan-Compass"><a href="#E-Manhattan-Compass" class="headerlink" title="E. Manhattan Compass"></a>E. Manhattan Compass</h3><p>首先转切比雪夫距离，这样一个条件可以看作 $\Delta x=D,\Delta y\leq D$ 和反过来。不妨先考虑 $\Delta x=D$ 的情况。</p>
<p>这样对 $x$ 排序后每个 $y$ 对应的就是一个区间。但是直接连边显然会炸。考虑如果当前区间与上一个区间有交，那么只需要与上一个区间连一条边即可。</p>
<p>所以我们每次把连边的区间与上一个区间右端点取 $\max$，这样每个点最多被连 $2$ 次，然后跑一个 $dfs$ 即可。</p>
<p>复杂度 $O(n\log n)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,u;</span><br><span class="line">	<span class="built_in">node</span>(<span class="keyword">int</span> X=<span class="number">0</span>,<span class="keyword">int</span> Y=<span class="number">0</span>):<span class="built_in">x</span>(X),<span class="built_in">y</span>(Y),<span class="built_in">u</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">node</span>(<span class="keyword">int</span> X,<span class="keyword">int</span> Y,<span class="keyword">int</span> D):<span class="built_in">x</span>(X+Y),<span class="built_in">y</span>(X-Y),<span class="built_in">u</span>(D)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x==a.x?y&lt;a.y:x&lt;a.x;&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">node <span class="keyword">operator</span> +(<span class="keyword">const</span> node a,<span class="keyword">const</span> node b)&#123;<span class="keyword">return</span> <span class="built_in">node</span>(a.x+b.x,a.y+b.y);&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[N&lt;&lt;<span class="number">3</span>],to[N&lt;&lt;<span class="number">3</span>],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cnt]=head[u];to[cnt]=v;</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> deg[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> dx,<span class="keyword">int</span> dy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);node lp=<span class="built_in">node</span>(-dx,-dy),rp=<span class="built_in">node</span>(-dx,dy+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l=<span class="number">1</span>,r=<span class="number">1</span>,v=<span class="number">1</span>;i&lt;=n;i++,v--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;l&lt;n &amp;&amp; p[l]&lt;p[i]+lp;l++);</span><br><span class="line">		<span class="keyword">for</span>(;r&lt;=n &amp;&amp; p[r]&lt;p[i]+rp;r++);</span><br><span class="line">		deg[p[i].u]+=r-l;</span><br><span class="line">		<span class="keyword">for</span>(v=<span class="built_in">max</span>(v,l);v&lt;r;v++)</span><br><span class="line">			<span class="built_in">add</span>(p[i].u,p[v].u),<span class="built_in">add</span>(p[v].u,p[i].u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=deg[u];vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]]) ans+=<span class="built_in">dfs</span>(to[i]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		p[i]=<span class="built_in">node</span>(x,y,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> D=<span class="built_in">max</span>(<span class="built_in">abs</span>(p[a].x-p[b].x),<span class="built_in">abs</span>(p[a].y-p[b].y));</span><br><span class="line">	<span class="built_in">solve</span>(D,D);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">swap</span>(p[i].x,p[i].y);</span><br><span class="line">	<span class="built_in">solve</span>(D,D<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">dfs</span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Shuffling"><a href="#F-Shuffling" class="headerlink" title="F. Shuffling"></a>F. Shuffling</h3><p>首先如果两个操作 $[l,r],[l’,r’],l&lt;l’$ 如果有 $r&gt;r’$ 那么 $[l’,r’]$ 显然莫的用处。</p>
<p>这样我们也可以选定若干没用用处的区间，即对于每一个 $i$ 我们都找到最右端不改变答案的值 $p_i$。</p>
<p>考虑处理到 $i$ 时，我们能做的是讨论 $i$ 是 $0$ 还是 $1$。</p>
<p>考虑进行 $dp$。用 $f_{i,j}$ 表示已经处理了 $[1,p_{i-1}]$，当前候选列中还有 $j$ 个 $1$（即还有 $j$ 个 $1$ 可以被任意放置于后续位置）。</p>
<p>首先这次操作会使得 $(p_{i-1},p_i]$ 的 $1$ 加入候选列。如果填 $1$ 会导致候选列中 $1$ 个数减 $1$。</p>
<p>复杂度 $O(n^2)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> pos[N],f[N][N];<span class="comment">//f_&#123;i,j&#125;:The count of &#x27;1&#x27; in [1,i]</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> g[N],fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=mod<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) r=<span class="number">1ll</span>*r*a%mod;</span><br><span class="line">		a=<span class="number">1ll</span>*a*a%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n=N<span class="number">-10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=fac[<span class="number">0</span>]=<span class="number">1</span>;i&lt;=n;i++) fac[i]=<span class="number">1ll</span>*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">ksm</span>(fac[n]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inv[i]=<span class="number">1ll</span>*inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b || b&lt;<span class="number">0</span>?<span class="number">0</span>:<span class="number">1ll</span>*fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	s[++n]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pos[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		pos[l]=<span class="built_in">max</span>(pos[l],r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[i]=g[i<span class="number">-1</span>]+(s[i]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) pos[i]=<span class="built_in">max</span>(pos[i],pos[i<span class="number">-1</span>]);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> d=g[pos[i]]-g[pos[i<span class="number">-1</span>]];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=pos[i<span class="number">-1</span>]-(i<span class="number">-1</span>);j++)</span><br><span class="line">			f[i][j+d]=(f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j+<span class="number">1</span>])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="AtCoder-Regular-Contest-066"><a href="#AtCoder-Regular-Contest-066" class="headerlink" title="AtCoder Regular Contest 066"></a><a href="https://atcoder.jp/contests/arc066">AtCoder Regular Contest 066</a></h2><h3 id="D-Xor-Sum"><a href="#D-Xor-Sum" class="headerlink" title="D. Xor Sum"></a>D. Xor Sum</h3><p>可以发现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x+y = (x&amp;y)&lt;&lt;<span class="number">1</span> + (x ^ y)</span><br></pre></td></tr></table></figure>

<p>容易证明，如果没有 $n$ 的限制，每一位 $(x,y)$ 只有 ${(0,0),(1,0),(1,1)}$。</p>
<p>对三种情况讨论，有 $f_{i,j}\rightarrow f_{i+1,j<em>2},f_{i+1,j</em>2+1},f_{i+1,j*2+2}$。</p>
<p>反过来就可以直接 $dp$。</p>
<p>容易发现时间复杂度 $T(n)=T(\frac{n}2)+T(\frac{n}2-1)+O(\log n)$。</p>
<p>容易证明复杂度 $O(\log^2 n)$ 级别。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;ll,<span class="keyword">int</span>&gt;f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f.<span class="built_in">count</span>(x)) <span class="keyword">return</span> f[x];</span><br><span class="line">	<span class="keyword">return</span> f[x]=((ll)<span class="built_in">F</span>(x/<span class="number">2</span>)+<span class="built_in">F</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">F</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;f[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">F</span>(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="E-Addition-and-Subtraction-Hard"><a href="#E-Addition-and-Subtraction-Hard" class="headerlink" title="E. Addition and Subtraction Hard"></a>E. Addition and Subtraction Hard</h3><p>考虑括号一定加在减号后面，且最多不会套超过两层，否则一定可以被替换掉。</p>
<p>所以用 $f_{i,j}$ 表示到 $i$ 套了 $j$ 层括号的方案数。</p>
<p>复杂度 $O(n)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 10000000000000000ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll f[N][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,x;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>]=x;f[<span class="number">1</span>][<span class="number">1</span>]=f[<span class="number">1</span>][<span class="number">2</span>]=-inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) x=-x;</span><br><span class="line">		<span class="built_in">memcpy</span>(f[i],f[i<span class="number">-1</span>],<span class="built_in"><span class="keyword">sizeof</span></span>(f[i]));</span><br><span class="line">		f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>])+x;</span><br><span class="line">		f[i][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i<span class="number">-1</span>][<span class="number">2</span>])-x;</span><br><span class="line">		f[i][<span class="number">2</span>]+=x;</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) f[i][<span class="number">2</span>]=<span class="built_in">max</span>(f[i][<span class="number">2</span>],f[i][<span class="number">1</span>]),f[i][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(f[n][<span class="number">1</span>],f[n][<span class="number">0</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="F-Contest-with-Drinks-Hard"><a href="#F-Contest-with-Drinks-Hard" class="headerlink" title="F. Contest with Drinks Hard"></a>F. Contest with Drinks Hard</h3><p>考虑区间 $[l,r]$ 如果选择了，那么满足条件的二元组等于 $\binom{r-l+1}{2}$。拆开显然是一个与区间程度有关的二次函数。</p>
<p>考虑如何处理修改。令 $f_i$ 表示 $[1,i]$ 的答案，$g_i$ 表示 $[i,n]$ 的答案，$h_i$ 表示强制选择 $i$ 的答案，显然单次修改的答案就是 $\max(f_{i-1}+g_{i+1},h_i+X-a_i)$。</p>
<p>$f$ 和 $g$ 可以通过斜率优化求出，考虑求出 $h$。用分治，处理区间 $[l,r]$ 强制经过 $m=\lfloor\frac{l+r}{2}\rfloor$ 的情况，可以发现左右两边各是两个斜率优化。</p>
<p>所以总共四个斜率优化。复杂度 $O(n\log n)$。瓶颈在于分治。</p>
<h4 id="代码咕咕咕了"><a href="#代码咕咕咕了" class="headerlink" title="代码咕咕咕了"></a><font color=red>代码咕咕咕了</font></h4><h2 id="AtCoder-Regular-Contest-067"><a href="#AtCoder-Regular-Contest-067" class="headerlink" title="AtCoder Regular Contest 067"></a><a href="https://atcoder.jp/contests/arc067">AtCoder Regular Contest 067</a></h2><h3 id="E-Grouping"><a href="#E-Grouping" class="headerlink" title="E. Grouping"></a>E. Grouping</h3><p>直接 dp，令 $f_{i,j}$ 表示已经选了 $i$ 个人，当前的组是 $j$ 组。枚举一下当前组选多少个。</p>
<p>复杂度 $O(n^2\ln n)$。</p>
<p>太水了，<font color=green>代码咕咕咕了</font>。</p>
<h3 id="F-Yakiniku-Restaurants"><a href="#F-Yakiniku-Restaurants" class="headerlink" title="F. Yakiniku Restaurants"></a>F. Yakiniku Restaurants</h3><p>不带 $\log$ 的做法还是挺妙的。</p>
<p>首先发现 $n$ 很小，也就是说最后可以枚举答案是哪一段区间。考虑对于每一个 $b_{i,j}$ 求出它会对那些区间造成贡献，这个可以通过单调栈求出。</p>
<p>这样就变成一个二维数点问题。由于矩形长度只有 $5000$，直接前缀和即可。复杂度 $O(n^2+nm)$。</p>
<details>
    <summary>查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll a[N],c[N][N];<span class="keyword">int</span> b[N][M];</span><br><span class="line"><span class="keyword">int</span> l[N],r[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) b[<span class="number">0</span>][i]=b[n+<span class="number">1</span>][i]=inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=m;p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">int</span> s[N];</span><br><span class="line">		<span class="keyword">int</span> tp=<span class="number">1</span>;s[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(b[s[tp]][p]&lt;b[i][p]) tp--;</span><br><span class="line">			l[i]=s[tp]+<span class="number">1</span>;s[++tp]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		tp=<span class="number">1</span>;s[<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(b[s[tp]][p]&lt;b[i][p]) tp--;</span><br><span class="line">			r[i]=s[tp]<span class="number">-1</span>;s[++tp]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v=b[i][p];</span><br><span class="line">			c[l[i]][i]+=v;c[i+<span class="number">1</span>][i]-=v;</span><br><span class="line">			c[l[i]][r[i]+<span class="number">1</span>]-=v;c[i+<span class="number">1</span>][r[i]+<span class="number">1</span>]+=v;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		printf(&quot;%d:\n&quot;,p);</span></span><br><span class="line"><span class="comment">//		for(int i=1;i&lt;=n;i++) printf(&quot;%d %d\n&quot;,l[i],r[i]);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) c[i][j]+=c[i<span class="number">-1</span>][j]+c[i][j<span class="number">-1</span>]-c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> r=l;r&lt;=n;r++) ans=<span class="built_in">max</span>(ans,c[l][r]-(a[r]-a[l]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 068 ~ 072</title>
    <url>/2021/10/25/arc068-072/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>C</strong></th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ARC068</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
</tr>
<tr>
<td align="center"><strong>ARC069</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
</tr>
<tr>
<td align="center"><strong>ARC070</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>ARC071</strong></td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
</tr>
<tr>
<td align="center"><strong>ARC072</strong></td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+1}}$</td>
<td align="center">$\color{red}{\texttt{+}}$</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="AtCoder-Regular-Contest-068"><a href="#AtCoder-Regular-Contest-068" class="headerlink" title="AtCoder Regular Contest 068"></a><a href="https://atcoder.jp/contests/arc068">AtCoder Regular Contest 068</a></h2><h3 id="E-Snuke-Line"><a href="#E-Snuke-Line" class="headerlink" title="E. Snuke Line"></a>E. Snuke Line</h3><p>考虑最难办的事情其实就是每个车站内自己的去重。可以发现，对于 $d$ 的列车，如果某个区间长度 $\geq d$，那么其必然会被经过，否则其至多被经过一次。</p>
<p>所以直接处理按从小到大顺序枚举 $d$，对于长度大于当前 $d$ 的区间不用加入，复杂度 $O(n\log n)$。</p>
<h4 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc068/submissions/9697163">提交记录</a></h4><h3 id="F-Solitaire"><a href="#F-Solitaire" class="headerlink" title="F. Solitaire"></a>F. Solitaire</h3><p>考虑加入存在完成后整个序列一定是 $\text{/}$ 形状的，考虑要让 $1$ 出现在第 $k$ 个位置，那么还会剩下 $n-k-1$ 个，可以发现无论如何剩下的一定是一段递增或是递减的序列。且其中的最大值小于同向部分弹出的最小值。</p>
<p>用 $f _ {i,j}$ 表示 前 $k-1$ 个数中，已确定了 $i$ 个数，最小值为 $j$。</p>
<p>考虑新加的数，有转移式 $f _ {i,j}\rightarrow f _ {i+1,j}\ ,\ f _ {i+1,k\leq j}$。</p>
<p>后者直接后缀和处理，复杂度 $O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll f[N][N],g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	g[n+<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-k<span class="number">-1</span>;i++) res=res*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			(g[i][j+<span class="number">1</span>]+=f[i+<span class="number">1</span>][j]+g[i+<span class="number">1</span>][j])%=mod;</span><br><span class="line">			(f[i][j]+=f[i+<span class="number">1</span>][j]+g[i+<span class="number">1</span>][j])%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--) (f[i][j]+=f[i][j+<span class="number">1</span>])%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>][n-k]*res%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AtCoder-Regular-Contest-069"><a href="#AtCoder-Regular-Contest-069" class="headerlink" title="AtCoder Regular Contest 069"></a><a href="https://atcoder.jp/contests/arc069">AtCoder Regular Contest 069</a></h2><h3 id="E-Frequency"><a href="#E-Frequency" class="headerlink" title="E. Frequency"></a>E. Frequency</h3><p>考虑策略显然是用一条线从上往下压，同时压到的部分从后往前删。</p>
<p>直接维护此时最小的位置与要删的数量即可。复杂度 $O(n\log n)$。</p>
<h4 id="提交记录-1"><a href="#提交记录-1" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc069/submissions/26617046">提交记录</a></h4><h3 id="F-Flags"><a href="#F-Flags" class="headerlink" title="F. Flags"></a>F. Flags</h3><p>考虑二分答案，这样相当于若干条“选了 $x$ 就不能选 $y$”，直接跑不太行，直接线段树优化建图跑 2-sat 即可。</p>
<p>复杂度 $O(n\log^2 n)$。</p>
<h4 id="提交记录-2"><a href="#提交记录-2" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc069/submissions/8526354">提交记录</a></h4><h2 id="AtCoder-Regular-Contest-070"><a href="#AtCoder-Regular-Contest-070" class="headerlink" title="AtCoder Regular Contest 070"></a><a href="https://atcoder.jp/contests/arc070">AtCoder Regular Contest 070</a></h2><h3 id="E-NarrowRectangles"><a href="#E-NarrowRectangles" class="headerlink" title="E. NarrowRectangles"></a>E. NarrowRectangles</h3><p>容易发现若干 $|x-a_i|$ 构成的函数一定是凸的，考虑大力维护这个凸函数。</p>
<p>考虑用小根堆维护最小值右边的函数，大根堆维护左边，分别维护断点。</p>
<p>考虑每次加入一个元素后的影响：相当于在最优位置插入了一条斜率为 $0$ 的线段，然后比 $r$ 小的 $+1$，比 $r$ 大的 $-1$。</p>
<p>考虑每次至多 $+1$，所以至多把每个堆的一个元素扔到另一个堆里，所以复杂度是对的。</p>
<p>复杂度 $O(n\log n)$。</p>
<h4 id="提交记录-3"><a href="#提交记录-3" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc070/submissions/26807928">提交记录</a></h4><h2 id="AtCoder-Regular-Contest-071"><a href="#AtCoder-Regular-Contest-071" class="headerlink" title="AtCoder Regular Contest 071"></a><a href="https://atcoder.jp/contests/arc071">AtCoder Regular Contest 071</a></h2><h3 id="E-TrBBnsformBBtion"><a href="#E-TrBBnsformBBtion" class="headerlink" title="E. TrBBnsformBBtion"></a>E. TrBBnsformBBtion</h3><p>首先直接把所有 $B$ 变成 $A$ 再消掉，一定可以得到 $\leq 2$ 个 $A$。</p>
<p>然后同样从 $\leq 2$ 个 $A$ 一定可以变成任何串。</p>
<p>所以令 $A=1,B=2$，两个串可以互相转化当且仅当两个串的和模 $3$ 相等。</p>
<h4 id="提交记录-4"><a href="#提交记录-4" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc071/submissions/26808210">提交记录</a></h4><h3 id="F-Infinite-Sequence"><a href="#F-Infinite-Sequence" class="headerlink" title="F. Infinite Sequence"></a>F. Infinite Sequence</h3><p>考虑如果有超过两个非 $1$ 的位置，后面一定全部相等。</p>
<p>如果第一个填的是 $k,k&gt;1$，并且后面不全相等，那么后面 $k$ 个必须是 $1$。</p>
<p>所以枚举第一个填什么，可以列出 dp 式子：</p>
<p>$$f_i=f_{i+1}+(n-1)^2+\sum_{k\geq 2}f_{i+k+1}$$</p>
<p>直接后缀和一下即可。复杂度 $O(n)$。</p>
<h4 id="提交记录-5"><a href="#提交记录-5" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc071/submissions/26808430">提交记录</a></h4><h2 id="AtCoder-Regular-Contest-072"><a href="#AtCoder-Regular-Contest-072" class="headerlink" title="AtCoder Regular Contest 072"></a><a href="https://atcoder.jp/contests/arc072">AtCoder Regular Contest 072</a></h2><h3 id="D-Alice-amp-Brown"><a href="#D-Alice-amp-Brown" class="headerlink" title="D. Alice&amp;Brown"></a>D. Alice&amp;Brown</h3><p>打个表发现答案是 $|X-Y|\leq 1$。考虑证明：</p>
<ul>
<li>首先 $(0,0),(1,1),(0,1),(1,0)$ 显然先手必败。</li>
<li>对于 $|X-Y|&gt;1$ 不妨假设 $X&gt;Y$，这样从 $X$ 中取 $\lceil\frac{X-Y}{3}\rceil$ 就会变成 $|X-Y|\leq 1$。</li>
<li>对于 $|X-Y|\leq 1$ 显然不存在构造。</li>
</ul>
<h3 id="E-Alice-in-linear-land"><a href="#E-Alice-in-linear-land" class="headerlink" title="E. Alice in linear land"></a>E. Alice in linear land</h3><p>设修改的位置是 $p$。首先 $1\sim p$ 部分处理的结果是固定的，对于修改来说，显然此时距离原点越远越好。</p>
<p>从后往前我们尝试构造 $f_i$ 表示从 $i$ 开始最小的距离满足不能到达。容易发现如果我们知道了 $f_{i+1}$，对于 $a_i$ 我们只要考虑会不会影响到达，如果不会就直接取上一个值，否则我们构造 $f_{i+1}+a_i$。</p>
<p>最后只要判断这两个值哪个大即可。</p>
<h4 id="提交记录-6"><a href="#提交记录-6" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc072/submissions/26810848">提交记录</a></h4><h2 id="F-Dam"><a href="#F-Dam" class="headerlink" title="F. Dam"></a>F. Dam</h2><p>首先显然只要让总热量最大，除以 $L$ 就是答案。</p>
<p>设 $f_i(x)$ 表示第 $i$ 次加水后，剩余水量为 $x$ 的最大热量，容易发现此时不断放水就可以取到原点线段上的点，所以这个函数一定是上凸的。</p>
<p>尝试维护这个凸包。可以发现当冲入 $(x,y)$ 的水后，等同于在前面加上了 $(x,y)$ 这个向量。如果此时队首向量斜率大于当前向量，换句话说我们不会主动放掉队首对应的水，那么就直接混合这两部分即可。</p>
<p>最后我们只需要截取 $f(L)$ 即可，可以发现超过 $L$ 的可以直接扔掉，所以用一个双端队列即可。</p>
<p>复杂度 $O(n)$。</p>
<h4 id="提交记录-7"><a href="#提交记录-7" class="headerlink" title="提交记录"></a><a href="https://atcoder.jp/contests/arc072/submissions/26814292">提交记录</a></h4>]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Petrozavodsk Winter Camp, Yandex Cup</title>
    <url>/2021/10/19/gym102155/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/102155">链接</a></h2><span id="more"></span>

<h2 id="A-Ability-Draft"><a href="#A-Ability-Draft" class="headerlink" title="A. Ability Draft"></a>A. Ability Draft</h2><p>神必大模拟。</p>
<h2 id="C-Block-Stock-and-Two-Smoking-Galaxy-Notes"><a href="#C-Block-Stock-and-Two-Smoking-Galaxy-Notes" class="headerlink" title="C. Block, Stock and Two Smoking Galaxy Notes"></a>C. Block, Stock and Two Smoking Galaxy Notes</h2><h2 id="K-Hiding-a-Tree"><a href="#K-Hiding-a-Tree" class="headerlink" title="K. Hiding a Tree"></a>K. Hiding a Tree</h2><h2 id="H-Hiding-a-Tree"><a href="#H-Hiding-a-Tree" class="headerlink" title="H. Hiding a Tree"></a>H. Hiding a Tree</h2><p>签到题。</p>
<h2 id="F-Shuffle"><a href="#F-Shuffle" class="headerlink" title="F. Shuffle"></a>F. Shuffle</h2><p>考虑一次操作显然是一个置换，所以一定会构成一个环。</p>
<p>对于环等价于环同构，直接 exKMP/Hash 即可。</p>
<p>考虑环长的限制，显然本质不同环长是 $O(\sqrt n)$ 的，对于长度相同的环一起暴力推，复杂度 $O(n\sqrt n)$。</p>
<p>事实上可以证明环长一定是 $\phi(n-1)$ 的约数，所以不同长度的环数就更小了。</p>
<h2 id="G-Piecewise-Linearity"><a href="#G-Piecewise-Linearity" class="headerlink" title="G. Piecewise Linearity"></a>G. Piecewise Linearity</h2><p>条件有两个，一个是最左端与最右端右斜率相反，另一个是不能加常数。</p>
<p>第二个很难判断？其实直接强行构造即可。最后如果构造不出来即无解。</p>
<h2 id="I-≤-or-≥"><a href="#I-≤-or-≥" class="headerlink" title="I.  ≤ or ≥"></a>I.  ≤ or ≥</h2><p>考虑设置权重函数 $f(k)=3^k$，总权重为 $S$，带权二分，可以发现每次相当于选择一个较小一边除以 $3$，这样至少使权重减少 $\frac 13S$。</p>
<p>毛估估一下大概就是 $50$ 左右。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 Chinese Multi-University Training, BeihangU Contest</title>
    <url>/2021/11/05/gym102253/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/102253">链接</a></h2><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
<th align="center">L</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+2}}$</td>
<td align="center">$\color{green}{\texttt{+3}}$</td>
<td align="center">$\color{red}{\texttt{+1}}$</td>
<td align="center"></td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center"></td>
<td align="center">$\color{gray}{\texttt{+3}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="A-Add-More-Zero"><a href="#A-Add-More-Zero" class="headerlink" title="A. Add More Zero"></a>A. Add More Zero</h2><h2 id="K-KazaQ’s-Socks"><a href="#K-KazaQ’s-Socks" class="headerlink" title="K. KazaQ’s Socks"></a>K. KazaQ’s Socks</h2><h2 id="B-Balala-Power"><a href="#B-Balala-Power" class="headerlink" title="B. Balala Power!"></a>B. Balala Power!</h2><h2 id="L-Limited-Permutation"><a href="#L-Limited-Permutation" class="headerlink" title="L. Limited Permutation"></a>L. Limited Permutation</h2><p>签到题。</p>
<h2 id="C-Colorful-Tree"><a href="#C-Colorful-Tree" class="headerlink" title="C. Colorful Tree"></a>C. Colorful Tree</h2><p>赛时想了一个很 simple 的做法：考虑点分，每种颜色分开处理贡献，一个点有贡献当且仅当其到点分中心路径上没有同色点。贡献可以通过容斥算出。复杂度 $O(n\log n)$，卡一卡常可以通过。</p>
<p>标算给的是对每种颜色维护一个序列表示所有该颜色对应子树和，dfs 过程中维护。</p>
<h2 id="F-Function"><a href="#F-Function" class="headerlink" title="F. Function"></a>F. Function</h2><p>手模一下可以发现 $a$ 中每个置换环需要映射到 $m$ 中一个置换环，并且环长是倍数关系。</p>
<p>将 $m$ 里所有的环长找出来，可以求出 $n$ 的每个长度的置换环可行匹配数，相乘即可。</p>
<h2 id="H-Hints-of-sd0061"><a href="#H-Hints-of-sd0061" class="headerlink" title="H. Hints of sd0061"></a>H. Hints of sd0061</h2><p>毛估估一下可以发现 $b$ 总共只有 $O(\log n)$ 个取值。并且所有本质不同询问的和是 $O(n)$ 的。所以直接调用库函数的 <code>nth_element</code> ，由于 $a$ 数组是随机的，能期望在 $O(n)$ 时间解决。</p>
<h2 id="J-Journey-with-Knapsack"><a href="#J-Journey-with-Knapsack" class="headerlink" title="J. Journey with Knapsack"></a>J. Journey with Knapsack</h2><p>首先额外 $m$ 物品先不管，假如前面的物品总大小为 $i$ 的方案数为 $f_i$，那么最后就是 $\sum f_{2n-b_i}$。</p>
<p>对于前面的部分，考虑生成函数：</p>
<p>$$F(x)=\prod_{i=1}^{n}(1+x^i+x^{2i}+\cdots+x^{a_ii})$$</p>
<p>$$=\prod_{i=1}^{n}\left(1-x^{i(a_i+1)}\right)\prod_{i=1}^{n}\frac{1}{1-x^i}$$</p>
<p>前面的式子只有 $O(\sqrt n)$ 项有值，直接暴力卷上去即可。后面是经典的拆分数，可以直接用五边形数处理，然而事实上可以直接根号分治，对于前 $O(\sqrt n)$ 暴力 dp，对于后面整体转移 $O(\sqrt n)$ 遍即可。</p>
<p>复杂度 $O(n\sqrt n)$。</p>
<h2 id="I-I-Curse-Myself"><a href="#I-I-Curse-Myself" class="headerlink" title="I. I Curse Myself"></a>I. I Curse Myself</h2><p>首先把所有环取出来，每个环可以删一条边。这样问题转化成：给定若干组物品，每组选恰好一个，问第 $k$ 大的选择是什么。</p>
<p>一个显然的想法是直接将每组物品排序，用 $n$ 元组 $(i_1,i_2,\cdots,i_n)$ 表示每组物品的最大值，每次取出最大的物品然后每组物品分别向后增广 $1$，可以得到 $n$ 个可能的待选值。这样时间复杂度是 $O(nk)$，但是空间也是 $O(nk)$，不大行。</p>
<p>考虑换种思路，依次处理每组物品，维护一个堆表示此时前 $k$ 大的物品。转移的时候类似记录，复杂度 $O(nk\log n)$，空间 $O(n+k)$ 的。事实上仔细分析可以发现设 $c_i$ 为第 $i$ 个环长，复杂度为 $O(k\sum\log c_i)=O(k\log(\prod c_i))=O(k\log 2^n)=O(nk)$。</p>
<h2 id="D-Division-Game"><a href="#D-Division-Game" class="headerlink" title="D. Division Game"></a>D. Division Game</h2><p>由于所有石子堆是相同的，令 $f(x)$ 表示一堆石子取 $x$ 次后恰好取完的方案数。可以发现无论何时都可以将一堆石子取至一颗，所以 $x$ 次没有取完的方案数就是 $f(x+1)$。这样对于第 $i$ 堆石子的答案就是 $f(x+1)^{i-1}f(x)^{k-i+1}$。</p>
<p>考虑求出 $f$。相当于是有 $m$ 堆石子，第 $i$ 堆是 $e_i$，每次至少取一颗，问 $x$ 次取完的方案数。</p>
<p>如果没有每次至少取一颗的限制，方案数可以对每堆石子分开计算，即：</p>
<p>$$g(x)=\prod_{i=1}^m\binom{e_i+x-1}{x-1}$$</p>
<p>对于每次至少取一颗的限制可以容斥，得到式子为：</p>
<p>$$f(x)=\sum_{i=0}^{x}(-1)^{x-i}g(i)\binom{x}{i}$$</p>
<p>$$f(x)=x!\sum_{i=0}^{x}\frac{(-1)^{x-i}}{(x-i)!}\frac{g(i)}{i!}$$</p>
<p>这可以看作卷积，而 $985661441$ 恰好是 NTT 模数。设 $n=\sum e_i$，复杂度 $O(n\log n)$。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2021 Summer Petrozavodsk Camp, Day 6</title>
    <url>/2021/11/06/gym102984/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/102984">链接</a></h2><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+4}}$</td>
<td align="center">$\color{red}{\texttt{+1}}$</td>
<td align="center"></td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{+2}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{red}{\texttt{+2}}$</td>
<td align="center"></td>
<td align="center">$\color{red}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="G-Solo-Tree-Game"><a href="#G-Solo-Tree-Game" class="headerlink" title="G. Solo Tree Game"></a>G. Solo Tree Game</h2><h2 id="E-Observer-Game"><a href="#E-Observer-Game" class="headerlink" title="E. Observer Game"></a>E. Observer Game</h2><p>签到题。</p>
<h2 id="D-Non-Decreasing-Subarray-Game"><a href="#D-Non-Decreasing-Subarray-Game" class="headerlink" title="D. Non-Decreasing Subarray Game"></a>D. Non-Decreasing Subarray Game</h2><details>
    <summary>题解</summary>

<p>显然后手会选 $L$ 或者 $R$。可以发现先手选的位置是单峰的，直接二分往较高的方向走。对于区间不降子区间数量可以直接前后缀和处理一下 $O(1)$ 查询。</p>
</details>

<h2 id="K-Determinant"><a href="#K-Determinant" class="headerlink" title="K. Determinant"></a>K. Determinant</h2><details>
    <summary>题解</summary>

<p>一个显然的想法是 $|A-xI|$ 是一个关于 $x$ 的 $n$ 次多项式，取 $n$ 个值插出来就是 $O(n^4)$ 的，显然过不去。</p>
<p>仔细想一想插出来的多项式满足 $x_0$ 是特征值时 $f(x_0)=0$。然后发现 $f$ 就是特征多项式。直接用 <a href="https://www.luogu.com.cn/problem/P7776">特征多项式</a> $O(n^3)$ 算出即可。</p>
<p>复杂度 $O(n^3+nq)$。</p>
</details>

<h2 id="A-Mango"><a href="#A-Mango" class="headerlink" title="A. Mango"></a>A. Mango</h2><details>
    <summary>题解</summary>

<p>大屎题。</p>
<p>先考虑暴力：贪心从 $M_k$ 从左往右扫，如果扫到 $M_{k-1}$ 并且 $[l,r]$ 存在一部分在 $M_{k-1}$ 中，那么向下递归。复杂度 $O(qnk)$。</p>
<p>考虑优化。首先特判只有一个 \$ 的情况（此时就是 $t_0^a+s+t_1^a$ 的形式），对于剩下情况，可以发现对于 $M_i,i&gt;60$ 的部分，只要保留第一个 \$ 与其前面的部分即可，因为 $M_{i-1}$ 长度一定超过 $10^{18}$。</p>
<p>这样对于 $M_{61}\sim M_n$ 部分等价于是 $t_0^a+M_{60}$，先特殊处理掉。那么剩下只有 $60$ 个串，复杂度变成 $O(qn\log V)$。</p>
<p>考虑如果询问是 $[1,r]$ 的形式显然直接扫过去复杂度就是正确的。否则对于每个串预处理前缀长度，二分找到需要输出第一个位置，那么每一层只会二分一次。</p>
<p>复杂度 $O(n\log q\log V)$。</p>
</details>

<h2 id="B-Koosaga’s-Problem"><a href="#B-Koosaga’s-Problem" class="headerlink" title="B. Koosaga’s Problem"></a>B. Koosaga’s Problem</h2><details>
    <summary>题解</summary>

<p>神仙题。</p>
<p>因为二分图是没有奇环的图，考虑用一种设置边权的方式，要求二分图异或和为 $0$，否则不为 $0$。</p>
<p>考虑构造一个生成树，对于非树边定义权值 $2^i$，并将树边异或上该权值，结论是这样处理之后的总边权异或和符合上述的要求。证明考虑对于每条边的权值分偶环和奇环讨论，偶环异或偶环还是偶环，偶环权值和为 $0$，奇环一定会有权值。</p>
<p>容易发现要割边一定不会割权值为 $0$ 的边，所以求割两条边之后合法的数量等价于求 $x\oplus y=0$ 的边 $x,y$ 数量。割一条边和不割边随便判一下就好了。</p>
<p>当然权值 $2^i$ 显然做不到，其实直接 <code>rand</code> 一个整数即可。</p>
</details>

<h2 id="F-Rhythm-Game"><a href="#F-Rhythm-Game" class="headerlink" title="F. Rhythm Game"></a>F. Rhythm Game</h2><details>
    <summary>题解</summary>

<p><del>神必音游，连击的倍率会是负的，而且还是单减的</del>。</p>
<p>考虑 dp，用 $f_{i,j}$ 表示当前在 $i$ 敲击了 $j$ 次的最优分数。显然枚举上一个一直连击的点 $k$ 就有一个 $O(n^3)$ 的 dp。</p>
<p>考虑优化。固定 $j$，容易发现 $i$ 维度有决策单调性，即不会出现敲击位置向后，一直连击的起始点反而向前的情况（因为连击越多分数越少），然后就是经典套路，直接分治处理即可。</p>
<p>复杂度 $O(n^2\log n)$。</p>
</details>

<h2 id="J-Setting-Maps"><a href="#J-Setting-Maps" class="headerlink" title="J. Setting Maps"></a>J. Setting Maps</h2><details>
    <summary>题解</summary>

<p>看到 $100$ 而且不太能 dp，考虑网络流。</p>
<p>首先对于 $k=1$ 的情况，可以每个点拆点，入点向出点连 $1$ 边，原图中的边连 $+\inf$，实际上是求最小割。</p>
<p>对于 $k&gt;1$ 的情况，考虑建 $k$ 层图，每层点之间和上面一样，每层点向下一层对应的出点连 $+\inf$，表示这个点被割掉了，不得不到下一层。$s$ 向 $(0,S)$ 连边，$(x,E)$ 向 $t$ 连边。</p>
<p>可以发现如果一条路径有少于 $k$ 个选择的点，那么这条路径一定对应 $s$ 到 $t$ 的流量。</p>
<p>但是这可能有一个问题：一个点如果被选择，本质上应该在 $k$ 层图中都被割掉。不过这没有影响，考虑处理一个点时只需要考虑 $S$ 到这个点路径中经过选择点最少的那条即可，其余不用考虑，转化到最小割上就是保证有流量的点中层数最小的那个点被割掉即可。</p>
<p>直接跑最小割，复杂度 $O(n^2k^2m)$。当然铁定是跑不满的。</p>
</details>

<h2 id="H-Stone-Catch-Game"><a href="#H-Stone-Catch-Game" class="headerlink" title="H. Stone Catch Game"></a>H. Stone Catch Game</h2><details>
    <summary>题解</summary>

<p>神仙题。</p>
<p>定义每个黑点的直接控制区域是它往射线的射线经过的点。可以发现如果白点经过这些点，白方必输。</p>
<p>考虑将每个点的射线画出来：</p>
<p><img src="/image/4.png"></p>
<p>结论：排除一个黑点直接控制白点（$x=y$）的情况，如果黑方胜，那么一定存在两个点，使得只保留这两个点仍然黑方胜。</p>
<p>证明显然，因为最后的限制一定只有包含白点的两条黑射线。</p>
<p>不妨把 $x&lt;y$ 的点与 $x&gt;y$ 的点分成两个集合，容易发现最后选出的点一定是两个集合中各选一个。</p>
<p><img src="/image/5.png"></p>
<p>接下来考虑怎样的两个点是合法的。贪心地想，左集合（红色射线）一定只会往下走，右集合（蓝色射线）一定只会往左走。</p>
<p>容易发现，如果最后两个点之间的距离是 $(2,2)$，即：</p>
<p><img src="/image/6.png"></p>
<p>容易发现此时白点永远出不去。设左边的点为 $(x_1,y_1)$，右边的点为 $(x_2,y_2)$，那么要求是 $y_1+x_2\leq \max(|y_1-y_2|-2,0)+\max(|x_2-x_1|-2,0)$。</p>
<p>然而这样并不是全部情况。因为我们钦定的一点是 $y_1&gt;y_2,x_1&lt; x_2$，然而事实上可能发生这种情况：</p>
<p><img src="/image/7.png"></p>
<p>但是贪心地想，我们无论如何不会把红线左移，那么可以认为是 $x_1=x_2$。$y$ 坐标同理。</p>
<p>所以最终的式子是：$y_1+x_2\leq \max(y_1-y_2-2,0)+\max(x_2-x_1-2,0)$。</p>
<p>考虑对左集合和右集合建单调栈，这样每个集合中 $(x,y)$ 均递增。然后枚举 $(x_1,y_1)$，分讨 $x_2,y_2$ 在两个括号内的情况。对应在单调栈上是四个区间，直接二分/双指针即可。</p>
<p>复杂度 $O(n\log n)$。事实上由于数据极水，直接 $O(n^2)$ 暴力扫过去就可以通过。</p>
</details>]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2021 ACM-ICPC, Asia Nanjing Regional Contest</title>
    <url>/2021/10/20/gym102992/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/102992">链接</a></h2><p>打垮了，又被 Clovers 带飞了。</p>
<span id="more"></span>

<h2 id="K-Co-prime-Permutation"><a href="#K-Co-prime-Permutation" class="headerlink" title="K. Co-prime Permutation"></a>K. Co-prime Permutation</h2><h2 id="L-Let’s-Play-Curling"><a href="#L-Let’s-Play-Curling" class="headerlink" title="L. Let’s Play Curling"></a>L. Let’s Play Curling</h2><h2 id="E-Evil-Coordinate"><a href="#E-Evil-Coordinate" class="headerlink" title="E. Evil Coordinate"></a>E. Evil Coordinate</h2><h2 id="M-Monster-Hunter"><a href="#M-Monster-Hunter" class="headerlink" title="M. Monster Hunter"></a>M. Monster Hunter</h2><p>签到题。</p>
<h2 id="F-Fireworks"><a href="#F-Fireworks" class="headerlink" title="F. Fireworks"></a>F. Fireworks</h2><p>设每做 $k$ 个处理一次，那么有代价 $w=nk+m+\frac{w}{(1-p)^k}$，移项得 $w=\frac{nk+m}{1-(1-p)^k}$，容易发现这是一个单峰函数，直接三分即可。</p>
<h2 id="H-Harmonious-Rectangle"><a href="#H-Harmonious-Rectangle" class="headerlink" title="H. Harmonious Rectangle"></a>H. Harmonious Rectangle</h2><p>诈骗题。首先当然用总方案减去不合法方案。也就是现在要统计不存在这样一个矩形的染色。</p>
<p>手模一下发现 $n=6,m=6$ 很难构造出来，打个暴力发现真的无解。</p>
<p>容易发现 $n&gt;8$ 时只有 $m=1$ 有解，所以特判 $n,m$ 中有一个 $1$ 的情况，对于其余 $n,m\leq 8$ 直接爆搜即可。</p>
<p>复杂度 $O(能过)$。</p>
<h2 id="J-Just-Another-Game-of-Stones"><a href="#J-Just-Another-Game-of-Stones" class="headerlink" title="J. Just Another Game of Stones"></a>J. Just Another Game of Stones</h2><p>吉司机线段树板子题，没什么好说的。</p>
<h2 id="A-Ah-It’s-Yesterday-Once-More"><a href="#A-Ah-It’s-Yesterday-Once-More" class="headerlink" title="A. Ah, It’s Yesterday Once More"></a>A. Ah, It’s Yesterday Once More</h2><p>构造题。打一个 checker 可以发现最长直径往往会成为限制。换句话说应该构造一张图使两点间最长距离尽可能长。</p>
<p>第一想法显然是绕圈圈，但这样只能达到 $15%$ 的成功率，因为这种情况下墙的数量太多了。关注到题目只要求四联通构成树即可，所以先往左上再往左下这样走更优。可以得到 $30%$ 的成功率。</p>
<h2 id="D-Degree-of-Spanning-Tree"><a href="#D-Degree-of-Spanning-Tree" class="headerlink" title="D. Degree of Spanning Tree"></a>D. Degree of Spanning Tree</h2><p>考虑随意取一个生成树，此时度数大于 $\frac n2$ 的点至多只有一个，不断调整直到满足条件。注意此时可能会出现另一个度数大于 $\frac n2$ 的点，但这两个点一定相邻，特判这条边即可。</p>
<p>实际上考虑正常生成树，不过每次加入要求度数不能超过 $\frac n2$，可以发现随机序列下正确率不低，多 shuffle 几次就过了。</p>
<h2 id="I-Interested-in-Skiing"><a href="#I-Interested-in-Skiing" class="headerlink" title="I. Interested in Skiing"></a>I. Interested in Skiing</h2><p>考虑总共只有 $2n$ 个点，暴力两两判断能否连边，如果可以连边就连单向边，边权为其斜率。这样可以得到一张图，而答案就是其最小瓶颈路。</p>
<p>直接二分答案然后 dfs 即可。复杂度 $O(n^3+n^2\log n)$。</p>
<h2 id="C-Certain-Scientific-Railgun"><a href="#C-Certain-Scientific-Railgun" class="headerlink" title="C. Certain Scientific Railgun"></a>C. Certain Scientific Railgun</h2><p>嘴巴一下，没有写过。</p>
<p>考虑最后实际上是选择一个矩形，使得所有点在矩形严格上下左右方向，代价是矩形周长减去到某个端点的曼哈顿距离。</p>
<p>考虑枚举下边界，维护每个上边界对应的左右边界之差。可以发现下边界上移过程中的代价是限制左右边界不能小于某个值，可以发现对应到上边界就是删去某些上边界，可以用 set 维护。</p>
<p>具体细节有一点恶心。</p>
<h2 id="G-Go"><a href="#G-Go" class="headerlink" title="G. Go"></a>G. Go</h2><p>考虑求出点双。分类讨论：</p>
<ul>
<li>翻转的是黑棋，直接判断四联通块中没有气的棋子数与是否有气即可。</li>
<li>翻转的是白棋。它需要是割点才会导致其他棋子被断气，只要看它链接的点双分量的气即可。</li>
</ul>
<p>细节有亿点恶心。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2021 Winter Petrozavodsk Camp, UPC contest</title>
    <url>/2021/10/27/gym103098/</url>
    <content><![CDATA[<h2 id="链接-题解"><a href="#链接-题解" class="headerlink" title="链接 题解"></a><a href="https://codeforces.com/gym/103098">链接</a> <a href="/file/Ptz_Camp_UPC_Contest_Analysis.pdf">题解</a></h2><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
</tr>
</thead>
<tbody><tr>
<td>$\color{green}{\texttt{+}}$</td>
<td>$\color{red}{\texttt{+}}$</td>
<td>$\color{green}{\texttt{+}}$</td>
<td>$\color{red}{\texttt{+}}$</td>
<td>$\color{green}{\texttt{+1}}$</td>
<td>$\color{gray}{\texttt{+2}}$</td>
<td></td>
<td></td>
<td>$\color{gray}{\texttt{+4}}$</td>
<td>$\color{gray}{\texttt{+}}$</td>
<td>$\color{green}{\texttt{+}}$</td>
<td>$\color{gray}{\texttt{+3}}$</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="I-Interesting-Scoring-Systems"><a href="#I-Interesting-Scoring-Systems" class="headerlink" title="I. Interesting Scoring Systems"></a>I. Interesting Scoring Systems</h2><h2 id="J-Joyful-Numbers"><a href="#J-Joyful-Numbers" class="headerlink" title="J. Joyful Numbers"></a>J. Joyful Numbers</h2><h2 id="K-Konigsberg-Bridges"><a href="#K-Konigsberg-Bridges" class="headerlink" title="K. Königsberg Bridges"></a>K. Königsberg Bridges</h2><p>签到题。</p>
<h2 id="C-Cartesian-MST"><a href="#C-Cartesian-MST" class="headerlink" title="C. Cartesian MST"></a>C. Cartesian MST</h2><p>考虑如果按照正常的 MST 做法，一个维度上一条边会在另一维度的每张图中都加一遍。容易发现加入答案的次数就是另一维度此时的连通块数。并且这次操作之后当前维度会恰好少一个连通块。</p>
<p>直接按类似 Kruskal 的做法做即可。复杂度 $O(m\log m)$。</p>
<h2 id="L-Long-Grid-Covering"><a href="#L-Long-Grid-Covering" class="headerlink" title="L. Long Grid Covering"></a>L. Long Grid Covering</h2><p>考虑大力压后两行建自动机，总共 $64$ 种状态，把不合法状态去掉大约只有 $40$ 种，直接转移即可。</p>
<p>题解给了一种人类智慧建自动机的做法。</p>
<p>复杂度 $O(M^3\log n)$，其中 $M$ 是自动机大小。</p>
<h2 id="E-Even-intervals"><a href="#E-Even-intervals" class="headerlink" title="E. Even intervals"></a>E. Even intervals</h2><p>看到 $n$ 只有 $5\times 10^4$ 还能离线，直接莫队。这样只需要支持往集合里加入/删除与求所有偶数位置之和。</p>
<p>直接权值线段树即可。复杂度 $O(n\sqrt m\log n)$。</p>
<h2 id="A-Adjacent-Rooks"><a href="#A-Adjacent-Rooks" class="headerlink" title="A. Adjacent Rooks"></a>A. Adjacent Rooks</h2><p>首先非常暴力地用 $f_{i,j,k,l}$ 表示当前放了 $i$，$i$ 位置在 $j$，$i-1$ 位置在 $k$，有 $l$ 个相邻差为 $1$。</p>
<p>然后发现的一点是 $i,i-1$ 的位置并不重要，只要知道是否相邻即可。</p>
<p>所以改成用 $f_{i,j,0/1/2}$ 表示有 $j$ 个相邻差为 $1$，$i$ 在 $j$ 不相邻/左边/右边。</p>
<p>按 $i+1$ 的位置分类讨论即可。复杂度 $O(n^2+T)$。</p>
<h2 id="F-Friendship-Circles"><a href="#F-Friendship-Circles" class="headerlink" title="F. Friendship Circles"></a>F. Friendship Circles</h2><p>直接暴力半平面交。如果一个点在答案中，那么其到原点中垂线向原点组成的半平面在最后的半平面交中。</p>
<p>考虑这里用斜率排序的做法有点恶心，可以反演之后求凸包。容易证明反演后凸包上的点一定对应是半平面交上的直线。</p>
<p>题解给了一个非常牛逼的转化：</p>
<p>容易发现最后圆经过原点一定比不经过优。那么考虑将这个圆反演，得到的是不包含原点的半平面。<br>根据圆反演的性质，圆内的点在半平面内。要求存在半平面只经过原点和某个特殊点 $p$，那么 $p$ 反演后的点一定在凸包上。<br>直接对所有点圆反演后求凸包即可。复杂度 $O(n\log n)$。</p>
<p>可以发现题解和半平面交的做法本质上是相同的。</p>
<h2 id="D-Display-of-Springs"><a href="#D-Display-of-Springs" class="headerlink" title="D. Display of Springs"></a>D. Display of Springs</h2><p>李超线段树板子题。</p>
<p>直接用李超线段树维护直线之间的关系即可。单次询问 $O(\log W)$。</p>
<h2 id="B-Beautiful-Permutation"><a href="#B-Beautiful-Permutation" class="headerlink" title="B. Beautiful Permutation"></a>B. Beautiful Permutation</h2><p>人类智慧题。</p>
<p>Clovers 赛后搓出来的，根本不会做。</p>
<p>题解给了一个难以描述的牛逼构造。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2021 Winter Petrozavodsk Camp, Day 5</title>
    <url>/2021/10/18/gym103260/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/103260">链接</a></h2><p>完全被 Clovers 带飞了。</p>
<span id="more"></span>

<h2 id="M-Discrete-Logarithm-is-a-Joke"><a href="#M-Discrete-Logarithm-is-a-Joke" class="headerlink" title="M. Discrete Logarithm is a Joke"></a>M. Discrete Logarithm is a Joke</h2><h2 id="J-Increasing-or-Decreasing"><a href="#J-Increasing-or-Decreasing" class="headerlink" title="J. Increasing or Decreasing"></a>J. Increasing or Decreasing</h2><h2 id="G-Remove-the-Prime"><a href="#G-Remove-the-Prime" class="headerlink" title="G. Remove the Prime"></a>G. Remove the Prime</h2><h2 id="I-Trade"><a href="#I-Trade" class="headerlink" title="I. Trade"></a>I. Trade</h2><p>签到题。</p>
<h2 id="A-Assignment-Problem"><a href="#A-Assignment-Problem" class="headerlink" title="A. Assignment Problem"></a>A. Assignment Problem</h2><p>直接暴力 dfs 就好了，毛估估一下复杂度 $O(2^{2m}m+n)$。</p>
<h2 id="E-Smol-Vertex-Cover"><a href="#E-Smol-Vertex-Cover" class="headerlink" title="E. Smol Vertex Cover"></a>E. Smol Vertex Cover</h2><p>首先显然有 $C\geq M$，所以只需要判断是否有 $C=M$ 或 $C=M+1$ 即可。</p>
<p>$M$ 可以用带花树求出。对于 $C=M$ 可以发现一条边两段至少有一个在点集里，考虑对于匹配的点建 2-sat 求解即可。对于 $C=M+1$ 暴力枚举额外选的一个点，然后再跑 2-sat 即可。</p>
<p>复杂度 $O(nm)$。</p>
<h2 id="C-Multiple"><a href="#C-Multiple" class="headerlink" title="C. Multiple?"></a>C. Multiple?</h2><p>结论：答案为 $\binom{n-1}{k-1}\varphi(n)$。</p>
<p>考虑一个性质：至少有一种数出现次数超过 $\frac n2$。证明：假设非众数数字个数为 $t$，将 $t$ 中数字两两求和，至多少有 $\min{t,\lfloor\frac{n-k}2\rfloor}$ 种不同的数。</p>
<p>那么这种数 $x$ 必须有 $(x,n)=1$。考虑令所有数乘上 $x^{-1}$，这样众数就变成 $1$ 了。</p>
<p>容易发现这样要求剩下 $\frac n2-k$ 个数的和不能超过 $\frac n2$，否则一定不合法。</p>
<p>可以发现去掉至少有 $\frac n2$ 个 $1$ 的限制，总共 $\frac 34 n$ 个数的和不能超过 $n$ 同样有至少 $\frac n2$ 个 $1$。</p>
<p>所以最后就是一个插板，组合数暴力计算可以通过。</p>
<h2 id="B-Lockout-vs-tourist"><a href="#B-Lockout-vs-tourist" class="headerlink" title="B. Lockout vs tourist"></a>B. Lockout vs tourist</h2><p>枚举当前已经选掉哪些点，从后往前，这样可以知道当前如果和对手选一样的结果，期望会是多少。</p>
<p>令 $B_i$ 为与对手选了一样的之后的期望，令 $q_i$ 为对方决策为 $i$ 的期望。在 $q_i$ 没有限制的情况下，根据纳什均衡容易得到：存在常数 $k$ 满足<br>$$<br>\forall i,A_i+q_i(B_i-A_i)=k\<br>$$<br>根据纳什均衡，$k$ 即最大收益。<br>$$<br>q_i=\frac{A_i-k}{A_i-B_i}<br>$$</p>
<p>$$<br>\sum q_i=1\Longrightarrow \sum\frac{A_i-k}{A_i-B_i}=1<br>$$</p>
<p>$$<br>k=\frac{\sum\frac{A_i}{A_i-B_i}-1}{\sum\frac{1}{A_i-B_i}}<br>$$</p>
<p>因为 $q_i$ 有不为负的限制，所以最后如果 $A_i\leq k$，那么直接放弃之后的所有点（换句话说对手不会去管这些点）。如果 $A_i\leq k,B_i\geq A_i$，那么对手放了还不如不放，同样会放弃，不过此时应该令 $k=A_i$。</p>
<p>复杂度 $O(2^nn\log n)$。</p>
<h2 id="L-Extreme-Wealth"><a href="#L-Extreme-Wealth" class="headerlink" title="L. Extreme Wealth"></a>L. Extreme Wealth</h2><p>考虑 dp，用 $f_{i,j}$ 表示还有 $i$ 个红色和 $j$ 个蓝色的期望倍率，不妨假设 $i&lt;j$。假设当前钱数是 $1$，赌了蓝色 $x$ 的钱（负数表示赌红色），期望收益是：<br>$$<br>\frac{j}{i+j}f_{i,j-1}(1+x)+\frac{i}{i+j}f_{i-1,j}(1-x)<br>$$<br>要么 $x=-1$ 要么 $x=1$。<del>（细思极恐）</del></p>
<p>算一算发现决策没有影响。换句话说一直摸鱼直到袋子里只有一种颜色的球然后 all in 即可。</p>
<p>所以最后贡献就是<br>$$<br>\frac{2^{n+m}}{\binom{n+m}{n}}<br>$$<br>正经做法：考虑 $n=m$ 时可以斯特林公式近似，对于其余情况可以发现每 $\sqrt V$ 至少 $\times 2$，所以直接暴力乘过去即可。</p>
<p>暴力做法：<br>$$<br>\frac{2^{n+m}}{\binom{n+m}{n}}=e^{(n+m)\ln2+\ln{n!}+\ln{m!}+\ln{(n+m)!}}<br>$$<br>$\ln{n!}$ 有一个非常牛逼的近似。直接用 python 计算即可。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-2020 Winter Petrozavodsk Camp, Day 8</title>
    <url>/2021/10/17/gym103261/</url>
    <content><![CDATA[<p>和 Clovers 一起打，被带飞了/ll。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/103261">链接</a></h2><span id="more"></span>

<h2 id="G-Petr’s-Algorithm"><a href="#G-Petr’s-Algorithm" class="headerlink" title="G. Petr’s Algorithm"></a>G. Petr’s Algorithm</h2><h2 id="F-Face-Recognition-Algorithm"><a href="#F-Face-Recognition-Algorithm" class="headerlink" title="F. Face Recognition Algorithm"></a>F. Face Recognition Algorithm</h2><h2 id="H-Greedy-Algorithm"><a href="#H-Greedy-Algorithm" class="headerlink" title="H. Greedy Algorithm"></a>H. Greedy Algorithm</h2><p>签到题</p>
<h2 id="I-Euclid’s-Algorithm"><a href="#I-Euclid’s-Algorithm" class="headerlink" title="I. Euclid’s Algorithm"></a>I. Euclid’s Algorithm</h2><p>考虑拆式子。<br>$$<br>(a+d)^k-a^k=\sum_{i=1}^{k}\binom{k}{i}d^ia^{k-i}<br>$$</p>
<p>需要保证约数 $x$ 满足 $\forall i\in[1,k],\binom{k}{i+1}d^i\mid x$ 成立。否则随便调整一下 $x$ 就不合法了。只要每次取 $\gcd(d,k)$ ，然后将 $d$ 除掉即可。</p>
<p>用 python 就不用高精了。</p>
<h2 id="L-Not-Our-Problem"><a href="#L-Not-Our-Problem" class="headerlink" title="L. Not Our Problem"></a>L. Not Our Problem</h2><p>超过三个 $-1$ 显然无解。</p>
<p>对于两个 $-1$ 的情况，可以转化成 $x\leq X,y\leq Y,xy\min(x,y)\leq C$ 的形式。</p>
<p>将询问 $(X,Y)$ 离线，可以发现 $\min(x,y)$ 只有 $10^6$ 级别，直接枚举 $\min(x,y)$，对符合条件的询问贡献即可。</p>
<p>复杂度 $O((n+\sqrt[3]{C})\log C)$。</p>
<h2 id="C-StalinSort-Algorithm"><a href="#C-StalinSort-Algorithm" class="headerlink" title="C. StalinSort Algorithm"></a>C. StalinSort Algorithm</h2><p>为了方便令 $p_{n+1}=n+1,p_0=0$。</p>
<p>可以将操作想象成一个栈和一个寄存器。如果当前元素小于栈顶直接删除，否则如果大于寄存器强制将寄存器入栈，否则可以选择交换寄存器。</p>
<p>令 $g_i$ 表示 $i$ 向后第一个比 $i$ 大的点，$f_i$ 表示点 $i$ 为栈顶时的结果。显然当 $i$ 为栈顶时一开始寄存器就是 $g_i$。考虑当 $i$ 作为栈顶时，区间 $[g_i,g_{g_i})$ 且大于 $p_i$ 的点都可以在栈顶为 $i$ 情况下作为新的寄存器。</p>
<p>那么有 $f_i+1\rightarrow f_j,j\in[g_i,g_{g_i}),a_j\in[a_i,n]$。显然是一个矩形加、单点查。显然 $g_i&gt;i$，而且 $[i,g_i)$ 不存在 $a_j&gt;a_i$ 的 $j$。所以可以把 $g_i$ 的左限制去掉。</p>
<p>赛时是用 cdq 分治，每次将左边的贡献加到右边，而右边的贡献就可以离线然后从右往左扫描线，因为是后缀取 $\max$ 所以可以树状数组，复杂度 $O(n\log^2 n)$。</p>
<p>赛后发现自己是个小丑，直接线段树就好了。复杂度 $O(n\log n)$。</p>
<h2 id="B-String-Algorithm"><a href="#B-String-Algorithm" class="headerlink" title="B. String Algorithm"></a>B. String Algorithm</h2><p>考虑根号分治。</p>
<p>设置阈值 $B$，对于 $k&gt;B$，考虑暴力计算，复杂度 $\displaystyle\sum_{i=B}^{n}\left(\frac{n}{i}\right)^2$，算一算是 $O(\frac{n^2}{B})$。</p>
<p>对于 $k\leq B$，考虑只有 $B$ 个，暴力将每个字符串每一位枚举，将其替换为 $?$，复杂度 $O(nB)$。</p>
<p>取 $B=\sqrt{n}$，复杂度 $O(n\sqrt{n})$。常数极大。</p>
<h2 id="E-Binary-Search-Algorithm"><a href="#E-Binary-Search-Algorithm" class="headerlink" title="E. Binary Search Algorithm"></a>E. Binary Search Algorithm</h2><p>首先看到求最小值，还有加入删除，查询至多 $2\log n$ 个点的，想到用堆。</p>
<p>但是直接二叉堆，会发现删除有问题。因为一般的堆删除都是转化成单点加 $\inf$，然后下推。但是下推过程是一个动态查询的过程，而这里要一次性给出询问，很难处理。</p>
<p>考虑使用可以合并的堆，而且要求不是均摊复杂度。这里用左偏树，斐波那契堆不知道可不可行。</p>
<p>考虑每次合并只需要知道两条右儿子链的相对顺序。这样每次插入/删除前先将这两条链查询出来，然后正常合并即可。这样每次恰好询问 $2\log n$。</p>
<h2 id="A-Um-nik’s-Algorithm"><a href="#A-Um-nik’s-Algorithm" class="headerlink" title="A. Um_nik’s Algorithm"></a>A. Um_nik’s Algorithm</h2><p>被卡常了。</p>
<p>考虑一个结论：网络流跑 $k$ 次 dinic，至少能得到 $\frac k{k+1}$ 的答案。具体可以反证增广路长度。</p>
<p>然后直接跑 dinic 即可。复杂度 $O(20n)$。</p>
<h2 id="K-Interactive-Algorithm"><a href="#K-Interactive-Algorithm" class="headerlink" title="K. Interactive Algorithm"></a>K. Interactive Algorithm</h2><p>可以发现 shuffle 一个序列期望答案是 $\frac{n-1}n$，所以 shuffle 之后 $0$ 或者 $1$ 的概率极大。</p>
<p>考虑用增量法，每次找到两个相邻的合并，合并之后就将他们粘一起，这样规模 $-1$。</p>
<p>显然有一个 $O(n^2)$ 做法是：每次 shuffle 直到结果为 $1$，然后枚举分界点翻转两边的序列再次询问，可以发现分开正确答案的分界点结果最小，然后合并该分界点即可。</p>
<p>有一个比较牛逼的优化：考虑每次二分，将左边的区间 shuffle，如果正确的分界点在右边，那么无论如何答案都不会为 $0$。所以如果 shuffle $10$ 次仍然不为 $0$ 就可以认为分界点在右边。这样是 $O(n\log^2 n)$ 级别的，可以通过。</p>
<p>事实上有一个非常暴力的做法：可以发现 $0$ 的概率很大，而 $0$ 意味着该序列相邻的数对都不合法。每个数对出现在序列中的概率是 $\frac 1n$，考虑到交互库不是自适应的，所以最后剩下大概率是一条链。</p>
<h2 id="D-FFT-Algorithm"><a href="#D-FFT-Algorithm" class="headerlink" title="D. FFT Algorithm"></a>D. FFT Algorithm</h2><h3 id="不会"><a href="#不会" class="headerlink" title="不会"></a><font color=red>不会</font></h3><h2 id="J-Closest-Pair-Algorithm"><a href="#J-Closest-Pair-Algorithm" class="headerlink" title="J. Closest Pair Algorithm"></a>J. Closest Pair Algorithm</h2><h3 id="不会-1"><a href="#不会-1" class="headerlink" title="不会"></a><font color=red>不会</font></h3>]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>XXII Open Cup. Grand Prix of Korea</title>
    <url>/2021/10/29/gym103371/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/103371">链接</a></h2><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
<th>K</th>
<th>L</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td>$\color{green}{\texttt{+1}}$</td>
<td>$\color{red}{\texttt{+3}}$</td>
<td>$\color{green}{\texttt{+1}}$</td>
<td></td>
<td>$\color{gray}{\texttt{+}}$</td>
<td></td>
<td>$\color{red}{\texttt{+}}$</td>
<td>$\color{gray}{\texttt{+1}}$</td>
<td></td>
<td>$\color{gray}{\texttt{+}}$</td>
<td>$\color{green}{\texttt{+}}$</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="J-Periodic-Ruler"><a href="#J-Periodic-Ruler" class="headerlink" title="J. Periodic Ruler"></a>J. Periodic Ruler</h2><p>签到题。</p>
<h2 id="H-Or-Machine"><a href="#H-Or-Machine" class="headerlink" title="H. Or Machine"></a>H. Or Machine</h2><p>对于整周期我们按位处理，记录一个数字至少多少轮后该位变成 $1$。这本质上是一个最短路，而且有效转移边边权只有 $0$ 和 $1$。</p>
<p>对于散周期暴力处理即可。复杂度 $O(l+n\log V)$。</p>
<h2 id="C-Equivalent-Pipelines"><a href="#C-Equivalent-Pipelines" class="headerlink" title="C. Equivalent Pipelines"></a>C. Equivalent Pipelines</h2><p>考虑 Kruskal 求最小瓶颈路的过程：从大到小加入一条边，其连接的两个集合之间的最小瓶颈路就是该边边权。</p>
<p>那么显然的想法就是枚举权值，将该权值连接的点集记录下来。可以发现这个过程可以用 Hash 实现：定义一个点集 Hash 函数为其所有点的 Hash 之和，连接两个点集的 Hash 值为两个点集 Hash 之积乘上边权。容易证明这个 Hash 函数与上述点集描述是等价的。</p>
<h2 id="E-Goose-Coins"><a href="#E-Goose-Coins" class="headerlink" title="E. Goose Coins"></a>E. Goose Coins</h2><p>容易证明，假设不考虑硬币数量限制，那么对于任何有解的情况，从大往小贪心地能取就取一定可以恰好达到目标方案。而此时的硬币数量一定是最小的。</p>
<p>同时也容易发现，任何方案可以用上述方案通过将若干 $c_i$ 硬币换成 $\frac{c_i}{c_{i-1}}$ 枚 $c_{i-1}$ 硬币得到。</p>
<p>考虑 dp，用 $f_{i,j,k}$ 表示当前在 $i$ 位置，已经放了 $j$ 个硬币，$c_i$ 硬币还有 $k$ 个的最小/最大重量。枚举 $i$ 硬币分裂几次，可以得到一个 $O(nk^3)$ 的 dp。事实上可以通过。</p>
<p>事实上我们并不关心当前位置到底有多少个硬币，而关心的是当前位置是否存在 $l$ 个硬币。所以我们可以不必枚举 $k$ 而是简单地后缀 $\min$，这样复杂度就变成 $O(nk^2)$。</p>
<h2 id="K-Three-Competitions"><a href="#K-Three-Competitions" class="headerlink" title="K. Three Competitions"></a>K. Three Competitions</h2><p>容易发现，如果把 $i$ 直接击败 $j$ 看做边 $i\rightarrow j$，那么这是一张竞赛图。而竞赛图的一大性质是：给定每个点的出度，可以得到 scc（强连通分量）。</p>
<p>具体来说，将所有点按照出度排序，可以证明如果两个点不在一个 scc 中，出度小的一定在前面，并且一个 scc 的所有点构成一个区间。</p>
<p>这样考虑如果一个区间中的点构成一个环，当且仅当加入这个环前是合法的竞赛图（出度之和 $=\frac{n(n-1)}2$），加入之后是合法的竞赛图，且任何一个真前缀都不是合法的竞赛图。直接扫一遍即可判断 scc。</p>
<p>最后求每个点出度可以直接二维偏序减三维偏序。复杂度 $O(n\log^2 n)$。</p>
<h2 id="A-Automatic-Sprayer-2"><a href="#A-Automatic-Sprayer-2" class="headerlink" title="A. Automatic Sprayer 2"></a>A. Automatic Sprayer 2</h2><p>大概就是根据二阶差分之后结果确定除去第一行和最后一行的所有行上数字之和。</p>
<p>同样也可以确定第一列和最后一列的所有行上数字之和。</p>
<p>然后列方程手动解出第一行和最后一行。</p>
<p>最后构造直接贪心，可以证明如果有解一定可以用贪心构造。</p>
<details>
    <summary>赛时题解</summary>

<pre><code>容易构造使矩阵只有唯一解，所以不用想一些乱搞了。  
令 X1|X2|X3|X4|... 表示第 1 行 1,2,3... 列的情况  
令 a1,a2... 表示第 1,2,... 列的总数  
X1=a2+2a3+3a4+...+W  
X2=a1+a3+2a4+...+W  
X3=2a1+a2+a4+...+W  
X4=3a1+2a2+a3+...+W  
D1=S1-S2=-a1+a2+a3+a4+...  
D2=S2-S3=-a1-a2+a3+a4+...  
D3=S3-S4=-a1-a2-a3+a4+...  
D1-D2=2a2  
D2-D3=2a3  
...  
可以求出 a2,a3,...,an-1  
同理 b2,b3,...,bn-1  
考虑求出 a1,an,b1,bn  
可以发现的是:  
S(n,n)=Xn+Yn=(n-1)a1+(n-1)b1+C1  
S(n,1)=Yn+X1=(n-1)a1+(n-1)bn+C2  
S(1,n)=Xn+Y1=(n-1)an+(n-1)b1+C3  
S(1,1)=X1+Y1=(n-1)an+(n-1)bn+C4  
看起来有 4 个方程，然而是线性相关的。。。最后一个方程可以用前三个表示。  
因为少了一个等式：行的点数之和等于列的点数之和。  
换句话说 X1+Xn=Y1+Yn+D  
这样等式就齐了。  
令 R1=C1-S(n,n) , R2=C2-S(n,1) , R3=C3-S(1,n)  
(n-1)a1=(2R1+R2-R3+D)/4  
(n-1)an=(-2R1+R2-3*R3+D)/4  
(n-1)b1=(2R1-R2+R3-D)/4  
(n-1)bn=(-2R1+3*R2+R3-D)/4  
最后贪心构造即可
</code></pre>
</details>

<h2 id="G-Lamb’s-Respite"><a href="#G-Lamb’s-Respite" class="headerlink" title="G. Lamb’s Respite"></a>G. Lamb’s Respite</h2><p>因为一开始是从满血出发的，一旦血条没了直接挂，这个过程可以看做是对序列求一个最小子段和，要求这个子段和加血量大于零。</p>
<p>然后注意到放技能期间只要小于 $\lceil\frac{H}{10}\rceil$ 是直接锁血的。实际上只需要判断有无触及这条线即可。这个和上面那个差不多。</p>
<p>所有操作可以用线段树维护前缀/后缀/整体最小完成。复杂度 $O(n\log n)$。</p>
<h2 id="B-Cilantro"><a href="#B-Cilantro" class="headerlink" title="B. Cilantro"></a>B. Cilantro</h2><p>首先可以证明的是：只要 Y 与 N 个数一样就一定有解。具体可以反证得到。</p>
<p>这样我们可以发现，如果前 $x$ 个元素入栈后仍然合法，那么 $y&lt;x$ 个元素入栈也一定合法。所以我们只需要求出最大的位置，然后该位置前所有与 $t_1$ 相同的字符全部合法。</p>
<p>直接二分可以做到 $O(n\log n)$。然而这题卡常过不去。</p>
<p>考虑优化。可以想到的一个贪心是，如果一个元素留在栈底，干脆就让它一直留在那里，直到最后一个匹配上的位置。</p>
<p>具体来说，我们对$s$ 从前往后，尝试将 $t$ 从后往前匹配。但是注意匹配的前提要求有解，换句话说当前元素后面没有被匹配的元素需要和 $s$ 的后缀 Y/N 的数量一样多。可以再维护一个指针，表示未被匹配部分 Y/N 的数量。</p>
<p>复杂度 $O(n)$。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关</title>
    <url>/2021/10/17/string/</url>
    <content><![CDATA[<p>这个页面主要放一些关于字符串的结论（猜想）。</p>
<p>有些猜想不知道能不能拿来出题。</p>
<span id="more"></span>

<h2 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul>
<li>$|s|$：$s$ 的长度。</li>
<li>$\Sigma$：字符集。</li>
<li>$\epsilon$：空串/空字符。</li>
<li>$s^k$：$s$ 复制 $k$ 遍。</li>
<li>$s^R$：$s$ 翻转。</li>
<li>$s_i$：$s$ 的第 $i$ 个字符（下标从 $1$ 开始）</li>
<li>$\sqrt[k]{s}$：$t=\sqrt[k]{s}\Longleftrightarrow s=t^k$。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>$\text{per}(s)$：$s$ 的最小周期。$\text{Per}(s)$：$s$ 所有周期组成集合。</li>
<li>$\text{Pre}(s)/\text{Suf}(s)$：$s$ 前缀/后缀集合。</li>
<li>$\text{Sub}(s)$：$s$ 所有子串的集合。</li>
<li>$\text{Cir}(s)$：$s$ 所有循环同构串集合。</li>
<li>$\text{Runs}(s)$：$s$ 所有 $\text{Runs}$ 集合。</li>
<li>$\text{Lyn}$：所有 Lyndon Word 集合。</li>
<li>$\text{Pal}$：所有回文串集合。</li>
<li>$\text{Pow}^k$：所有 $k$ 次方串集合。</li>
<li>以上所有集合都是字符串集合。</li>
<li>$\text{Len}(S)$ 表示字符串集合 $S$ 所有字符串总长度。</li>
<li>$\text{Min}(S)$ 表示字符串集合 $S$ 中字典序最小的串，$\text{Max}(S)$ 同理。</li>
</ul>
<h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><ul>
<li>$\text{Pow}$ 表示所有 $k\in \mathbb Z,k\geq 2$，$\text{Pow}^k$ 的并。</li>
<li>$\text{suf}_i(s)$：$s$ 从 $i$ 开始的后缀。$\text{pre}_i(s)$ 同理。</li>
<li>若 $x\in \mathbb{Z}$，则 $x\in \text{Per}(s)$ 等价于 $s[:x]\in\text{Per}(s)$，$\text{Pal}$ 等同理。</li>
<li>$\text{PalPre}(s)$ 等价于 $\text{Pal}\cap\text{Pre}(s)$，其余同理。</li>
<li>$\text{MinPre}(s)$ 表示最长前缀，其余同理。</li>
</ul>
<h2 id="经典结论"><a href="#经典结论" class="headerlink" title="经典结论"></a>经典结论</h2><details>
<summary>经典结论</summary>

<ol>
<li>若 $p,q\in\text{Per}(s)$，且 $p+q-\gcd(p,q)\leq |s|$，则 $\gcd(p,q)\in\text{Per}(s)$。</li>
<li>$\text{Sub}(s)$ 中本原平方串个数为 $O(|s|\log |s|)$。</li>
<li>$\text{Runs}(s)$ 的所有指数之和为 $O(n)$。</li>
<li>$s$ 的所有 border 可以被分为 $\log n$ 个等差数列。</li>
</ol>
</details>

<h2 id="已经证明的结论"><a href="#已经证明的结论" class="headerlink" title="已经证明的结论"></a>已经证明的结论</h2><h3 id="关于回文串"><a href="#关于回文串" class="headerlink" title="关于回文串"></a>关于回文串</h3><details>
<summary>结论</summary>

<ol>
<li><p>若 $s\in \text{PalPow}^k$，则 $\sqrt[k]s\in\text{Pal}$。</p>
 <details>
 <summary>证明</summary>

<p> 令 $t=\sqrt[k]s$。</p>
<p> 若 $k$ 为奇数有 $t=t^R$，若 $k$ 为偶数则有 $t^2\in\text{Pal}$ 都可以推出 $t\in\text{Pal}$。</p>
 </details></li>
<li><p>若 $p,q\in\text{PrePal}(s)$ 且 $p&lt; q,2p&gt;q$，则 $2p-q\in\text{PrePal}(s)$。</p>
 <details>
 <summary>证明</summary>
 
<p> $\forall x\in[1,2p-q],\ s_x=s_{p-x}=s_{q-p+x}$，那么 $s[p+1:q]$ 是一个回文串。</p>
<p> 那么 $s[1:2p-q]$ 也是一个回文串。</p>
 </details></li>
<li><p>若 $s\not\in \text{Pow}$，$\text{Cir}(s)$ 中至多有 $2$ 个串是回文串。</p>
 <details>
 <summary>证明</summary>

<p> 一种方法当然是暴力推，但事实上有些困难。</p>
<p> 有一种很巧妙的方法：将 $s$ 看做是一个定义在圆上的离散函数。那么循环串为回文串等价于该函数的对称轴。</p>
<p> 有两条不同对称轴的函数一定为周期函数，无论其是否为离散函数。</p>
<p> 故 $s$ 至多只有两条重合的对称轴。</p>
 </details></li>
<li><p>删去 $\text{PalPre}(s)$ 前 $\sqrt n$ 与后 $\sqrt n$ 个后剩下所有元素构成一个等差数列。</p>
 <details>
 <summary>证明</summary>

<p> 考虑假设删去前 $B$ 个元素与后 $B$ 个元素，最优构造一定是构造 $B+2$ 个 $\texttt{a}$ 然后构造一个 $\texttt{b}$，最后再复制 $B$ 遍。</p>
<p> 可以发现这种构造下至少要 $B^2$ 的字符串。</p>
 </details></li>
<li><p>树上本质不同回文串个数是 $O(n\sqrt n)$ 的。</p>
 <details>
 <summary>证明</summary>

<p> <a href="/file/Tight%20Bound%20for%20the%20Number%20of%20Distinct%20Palindromes%20in%20a%20Tree(2008.13209).pdf">完整证明见论文</a></p>
<p> 简要证明咕咕咕了。</p>
 </details></li>
</ol>
</details>

<h3 id="关于-Runs-Lyndon串-平方串"><a href="#关于-Runs-Lyndon串-平方串" class="headerlink" title="关于 Runs/Lyndon串/平方串"></a>关于 Runs/Lyndon串/平方串</h3><details>
<summary>结论</summary>

<ol>
<li><p>$s+w,w+t\in\text{Lyn}\Longrightarrow s+w+t\in\text{Lyn}$。</p>
 <details>
 <summary>证明</summary>

<p> 易得 $\text{MinSuf}(s+w+t)=\text{Min}\left(\text{Suf}(s+w)+t)\cup(\text{Suf}(s)+w+t)\right)$。</p>
<p> 根据定义有 $s+w\leq\text{MinSuf}(s+w)$。同样有 $w+t\leq\text{MinSuf}(w+t)&lt;\text{Minsuf}(t)$。</p>
<p> 故 $s+w+t\leq\text{MinSuf}(s+w+t)$，$s+w+t\in\text{Lyn}$。</p>
 </details></li>
<li><p>$\text{Len}(\text{Runs}(s))=O(n\log n)$。</p>
 <details>
 <summary>证明</summary>
 
<p> 根据 $\text{Runs}$ 的理论，任意两个 Lyndon Root 不交。</p>
<p> 所以容易发现对于串 $s$ 用如下方式递归构造：</p>
<ul>
<li>假设长度为 $l$ 的串总长度为 $F(l)$。</li>
<li>找到最长的 Lyndon Root $t$ 对应的 Runs，将序列划分成若干段。</li>
<li>假设该 $\text{Runs}$ 指数为 $k$，那么总长度为 $tk$，剩下若干段长度为 $kF(t)+F(n-kt)$，故 $F(n)=kF(t)+F(n-kt),k\geq 2$。</li>
</ul>
<p> 可以证明当 $k=2$ 时取最长为 $O(n\log n)$。</p>
 </details></li>
<li><p>$\text{Len}(\text{Pow}^2\text{Sub}(s))=O(|s|)$。</p>
 <details>
 <summary>证明</summary>
 
<p> 考虑用类似于 $6$ 的方法证明。</p>
<p> 一个 $\text{Run}$ $(l,r,p)$ 中至多只有 $\lfloor\frac{r-l+1}{p}\rfloor$ 个平方串，故 $\text{Pow}^2$ 串总长度不超过 $\text{Run}$ 总长度。</p>
<p> 而一个 $\text{Runs}$ 递归构造时有所有段全等，故 $F(n)=F(t)+F(n-kt)+O(k),k\geq 2$。总长度为 $O(|s|)$。</p>
 </details></li>
<li><p>$\text{Len}(\text{PowSub}(s))=O(|s|)$。</p>
 <details>
 <summary>证明</summary>
 看起来比定理 [$3$] 高级？其实不过把递推式换成了 $F(n)=F(t)+F(n-kt)+O(kt),k\geq 2$。
 
<p> 其实是一样的。。。</p>
 <details>
 <summary>推论</summary>

<p> 定义 Run $(l,r,p)$ 与 $(l’,r’,p’)$ 本质相同当且仅当 $r-l=r’-l’,s[l:r]=s[l’:r’]$。</p>
<p> 则 $\text{Len}(\text{Runs}(s))=O(|s|)$。</p>
<p> 看起来很牛逼，但貌似没有什么用。</p>
 </details>
 </details></li>
</ol>
</details>
]]></content>
      <tags>
        <tag>idea</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>【集训队作业2018】串串</title>
    <url>/2021/10/09/%E4%B8%B2%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://uoj.ac/problem/433">链接</a></h2><span id="more"></span>

<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一个字符串是双回文串当且仅当其能被划分成两个不为空回文串。</p>
<p>给定长度为 $n$ 的串 $s$，问其本质不同双回文串子串数量。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><del>怎么又是<a href="https://www.cnblogs.com/Flying2018/p/14032526.html"> 2018 年集训队作业</a></del>。</p>
<p>首先我们分析一下双回文串的性质，<del>发现它并没有什么性质</del>。</p>
<p>从定义入手，双回文串的定义似乎与 <a href="https://uoj.ac/problem/219">优秀的拆分</a> 很类似，只不过这里同一个串的所有拆分只记一次。那么我们不妨先求出所有“本质不同回文拆分方案数”之和，然后减去重复部分。</p>
<p>可以发现一个回文拆分方案必然由回文串 $A$ 和 $B$ 拼接而成。回文拆分 $A+B$ 和 $A’+B’$ 本质不同当且仅当 $A\neq A’$ 或 $B\neq B’$。</p>
<p>而一个字符串的本质不同回文串是 $O(n)$ 的。不妨将所有本质不同回文串标号。这样对于一个位置 $p$，求出 $s[:p-1]$ 的所有回文后缀集合 $A_p$ 和 $s[p:]$ 的所有回文前缀集合 $B_p$。最后求 $\displaystyle \bigcup_{p}\ \left((a,b)|a\in A_p,b\in B_p\right)$。当然直接算是 $O(n^2)$。</p>
<p>令 $\text{Suf}(S)$ 表示字符串 $S$ 的最长回文后缀。考虑一个回文串 $S$ 的回文后缀必然是 $\text{Suf}(S)$ 的某个后缀，如果我们把这个关系用树形结构表示出来，那么 $A$ 等价于 $\text{Suf}(s[:p-1])$ 对应节点到根的路径，$B$ 等价于 $\text{Suf}(s[p:])$ 对应节点到根的路径（显然前后缀在回文串中是等价的）。</p>
<p>可以发现这棵树其实就是回文自动机建完后 fail 边连成的树。将 $A$ 的每个点加到 $B$ 对应的节点上，那么等同于问：</p>
<p><strong>给定一颗树，有若干个点集，一开始点集只有一个点，支持合并两个点集，询问一个点集的所有点到根路径的并</strong>。</p>
<p>这是个经典问题，用 dfs 序排序，可以用 set 启发式合并做到 $O(n\log^2 n)$ 或者线段树合并做到 $O(n\log n)$。</p>
<hr>
<p>考虑如何去重。可以发现一个串被重复计算，说明其有一个长度大于一半的回文串。不妨设原串为 $S$，那么一定有：</p>
<p>$$<br>S=LTL^R,T=T^R,L\neq \varnothing<br>$$</p>
<p>假设 $T$ 是空串，那么显然有 $L=L^R$，说明 $S$ 是一个循环串，且 $L$ 是它的一个循环节。否则令 $S’=LT$，显然其有和 $S$ 一样的性质，可以归纳证明。所以如果一个串被重复计算，说明其一定是循环串。</p>
<p>考虑其最短循环节 $T$，令 $S=T^k$：</p>
<ul>
<li>如果 $T$ 是一个回文串，那么 $S=T^k$ 显然还是一个回文串。</li>
<li>如果 $T=A+B$ 是一个双回文串，那么 $S=T^k=(AB)^k=A+B(AB)^k$ 也是一个双回文串。</li>
<li>否则如果 $S=A+B$ 仍然是一个双回文串，由于 $A\neq T^{k’}$，所以 $\exists\ A_1+B_1= T$，故 $A=T^{k’}+A_1$ 为回文串，$B_1$ 同理，那么有 $A_1=A_1^R,B_1=B_1^R$，与假设不符。</li>
</ul>
<p>故 $S=T^k$ 是一个双回文串当且仅当 $T$ 是一个回文串或双回文串，而且可以发现如果 $T$ 是一个回文串那么 $S$ 存在 $k-1$ 种回文分割（因为存在一种分出空串的情况要减掉），否则存在 $k$ 种。</p>
<p>$$<br>aa|baa|baa|baa|b<br>$$</p>
<p>由于所有极长<strong>整</strong>循环串的数量不小于本原平方串，所以显然其上界为 $O(n\log n)$，那么对于循环节相同的整循环串，记录其中次数最大的即可。而对于存在 $k$ 种划分的整循环串，其多算的贡献为 $\frac{k(k-1)}{2}$。</p>
<p>总复杂度 $O(n\log^2 n)$（实现精细一点可能有 $O(n\log n)$）。</p>
<p>注意最后的部分需要对 $O(n)$ 个串扔进 Hash 桶中，单 Hash 的错误率很大，需要用到双 Hash。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>,C=<span class="number">26</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> fa[N],len[N],tot;</span><br><span class="line"><span class="keyword">namespace</span> PAM&#123;</span><br><span class="line">    <span class="keyword">int</span> ch[N][C],fail[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_nxt</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">for</span>(;s[p-len[u]<span class="number">-1</span>]!=s[p];u=fail[u]); <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> las,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="built_in">get_nxt</span>(las,p),c=s[p]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][c]) fail[++tot]=ch[<span class="built_in">get_nxt</span>(fail[u],p)][c],len[tot]=len[u]+<span class="number">2</span>,ch[u][c]=tot;</span><br><span class="line">        <span class="keyword">return</span> ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_nxtr</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">for</span>(;s[p+len[u]+<span class="number">1</span>]!=s[p];u=fail[u]); <span class="keyword">return</span> u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_r</span><span class="params">(<span class="keyword">int</span> las,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="built_in">get_nxtr</span>(las,p),c=s[p]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[u][c]) <span class="keyword">throw</span>;</span><br><span class="line">        <span class="keyword">return</span> ch[u][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;len[<span class="number">1</span>]=<span class="number">-1</span>;fail[<span class="number">0</span>]=<span class="number">1</span>;tot=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd_fa</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) fa[i]=fail[i]==<span class="number">0</span>?<span class="number">1</span>:fail[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;g[N];</span><br><span class="line"><span class="keyword">int</span> ap[N],bp[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">21</span>],_2[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;<span class="number">1</span>&lt;&lt;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ST&#123;</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">21</span>][N*<span class="number">2</span>],dep[N*<span class="number">2</span>],id[N*<span class="number">2</span>],dfn[N*<span class="number">2</span>],tot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dep[u]=dep[p]+<span class="number">1</span>;</span><br><span class="line">        id[++tot]=u;dfn[u]=tot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="built_in">dfs</span>(v,u),id[++tot]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) f[<span class="number">0</span>][i]=id[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++) _2[i]=_2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,p=<span class="number">2</span>;p&lt;=tot;i++,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j+p<span class="number">-1</span>&lt;=tot;j++)</span><br><span class="line">            <span class="keyword">if</span>(dep[f[i<span class="number">-1</span>][j]]&lt;dep[f[i<span class="number">-1</span>][j+p/<span class="number">2</span>]]) f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j+p/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=dfn[x],y=dfn[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">int</span> p=_2[y-x+<span class="number">1</span>],u=<span class="number">1</span>&lt;&lt;p;</span><br><span class="line">        <span class="keyword">return</span> dep[f[p][x]]&gt;dep[f[p][y-u+<span class="number">1</span>]]?f[p][y-u+<span class="number">1</span>]:f[p][x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> ST::lca;<span class="keyword">using</span> ST::dep;</span><br><span class="line"><span class="keyword">int</span> dfn[N],ind,id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[dfn[u]=++ind]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> seg_tree&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M=N*<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> ls[M],rs[M],cnt;</span><br><span class="line">    <span class="keyword">int</span> f[M],fl[M],fr[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f[u]=f[ls[u]]+f[rs[u]]-dep[<span class="built_in">lca</span>(id[fr[ls[u]]],id[fl[rs[u]]])];</span><br><span class="line">        fl[u]=fl[ls[u]]?fl[ls[u]]:fl[rs[u]];</span><br><span class="line">        fr[u]=fr[rs[u]]?fr[rs[u]]:fr[ls[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) u=++cnt;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;fl[u]=fr[u]=p,f[u]=dep[id[p]];<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p&lt;=mid) <span class="built_in">insert</span>(ls[u],l,mid,p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(rs[u],mid+<span class="number">1</span>,r,p);</span><br><span class="line">        <span class="built_in">upd</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ls[x]=<span class="built_in">merge</span>(ls[x],ls[y],l,mid);rs[x]=<span class="built_in">merge</span>(rs[x],rs[y],mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">upd</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> seg_tree::insert;<span class="keyword">using</span> seg_tree::merge;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">int</span> root[N];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:q[u]) <span class="built_in">insert</span>(root[u],<span class="number">1</span>,tot,dfn[v]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:g[u]) <span class="built_in">solve</span>(v),root[u]=<span class="built_in">merge</span>(root[u],root[v],<span class="number">1</span>,tot);</span><br><span class="line">    <span class="keyword">if</span>(u!=<span class="number">1</span>) ans+=<span class="built_in">max</span>(seg_tree::f[root[u]]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> runs&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1019260817</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line">    P <span class="keyword">operator</span> +(<span class="keyword">const</span> P a,<span class="keyword">const</span> P b)&#123;<span class="keyword">return</span> <span class="built_in">MP</span>((a.fi+b.fi)%mod,(a.se+b.se)%mod);&#125;</span><br><span class="line">    P <span class="keyword">operator</span> +(<span class="keyword">const</span> P a,<span class="keyword">const</span> <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> <span class="built_in">MP</span>((a.fi+b)%mod,(a.se+b)%mod);&#125;</span><br><span class="line">    P <span class="keyword">operator</span> -(<span class="keyword">const</span> P a,<span class="keyword">const</span> P b)&#123;<span class="keyword">return</span> <span class="built_in">MP</span>((a.fi-b.fi+mod)%mod,(a.se-b.se+mod)%mod);&#125;</span><br><span class="line">    P <span class="keyword">operator</span> *(<span class="keyword">const</span> P a,<span class="keyword">const</span> P b)&#123;<span class="keyword">return</span> <span class="built_in">MP</span>(<span class="number">1ll</span>*a.fi*b.fi%mod,<span class="number">1ll</span>*a.se*b.se%mod);&#125;</span><br><span class="line">    <span class="keyword">const</span> P B=<span class="built_in">MP</span>(<span class="number">233</span>,<span class="number">2333</span>);</span><br><span class="line">    <span class="keyword">int</span> s[N];</span><br><span class="line">    P h[N],bs[N],bh[N];</span><br><span class="line">    <span class="function">P <span class="title">get</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*bs[r-l+<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function">P <span class="title">getb</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> bh[l]-bh[r+<span class="number">1</span>]*bs[r-l+<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_pal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">get</span>(l,r)==<span class="built_in">getb</span>(l,r);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">qry_pal</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=ap[r];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=_2[dep[p]];i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(len[f[p][i]]&gt;r-l+<span class="number">1</span>) p=f[p][i];</span><br><span class="line">        <span class="keyword">if</span>(len[p]&gt;r-l+<span class="number">1</span>) p=f[p][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(len[p]==r-l+<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">is_pal</span>(l,r-len[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=n-<span class="built_in">max</span>(x,y)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(x,x+mid<span class="number">-1</span>)==<span class="built_in">get</span>(y,y+mid<span class="number">-1</span>)) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="built_in">min</span>(x,y);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(x-mid+<span class="number">1</span>,x)==<span class="built_in">get</span>(y-mid+<span class="number">1</span>,y)) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> l1,<span class="keyword">int</span> l2)</span></span>&#123;<span class="keyword">int</span> l=<span class="built_in">lcp</span>(l1,l2); <span class="keyword">return</span> s[l1+l]&lt;s[l2+l];&#125;</span><br><span class="line">    <span class="keyword">int</span> nxt[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lyndon</span><span class="params">(<span class="keyword">bool</span> ell)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i;i--) <span class="keyword">for</span>(nxt[i]=i+<span class="number">1</span>;nxt[i] &amp;&amp; <span class="built_in">cmp</span>(nxt[i],i)==ell;nxt[i]=nxt[nxt[i]]);&#125;</span><br><span class="line">    pair&lt;P,<span class="keyword">int</span>&gt; per[N*<span class="number">20</span>];<span class="keyword">int</span> pt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_runs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=n<span class="number">-1</span>;k;k--)</span><br><span class="line">        <span class="keyword">if</span>(nxt[k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dl=<span class="built_in">lcs</span>(k,nxt[k]),dr=<span class="built_in">lcp</span>(k,nxt[k]),p=nxt[k]-k;</span><br><span class="line">            <span class="keyword">int</span> l=k-dl+<span class="number">1</span>,r=nxt[k]+dr<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dl+dr&lt;=p) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;l+p &amp;&amp; i+<span class="number">2</span>*p<span class="number">-1</span>&lt;=r;i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">qry_pal</span>(i,i+<span class="number">2</span>*p<span class="number">-1</span>))</span><br><span class="line">            per[++pt]=<span class="built_in">MP</span>(<span class="built_in">get</span>(i,i+<span class="number">2</span>*p<span class="number">-1</span>),(r-i+<span class="number">1</span>)/p-<span class="built_in">is_pal</span>(i,i+<span class="number">2</span>*p<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=::s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        bs[<span class="number">0</span>]=<span class="built_in">MP</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=h[i<span class="number">-1</span>]*B+s[i],bs[i]=bs[i<span class="number">-1</span>]*B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) bh[i]=bh[i+<span class="number">1</span>]*B+s[i];</span><br><span class="line">        <span class="built_in">lyndon</span>(<span class="number">0</span>);<span class="built_in">make_runs</span>();</span><br><span class="line">        <span class="built_in">lyndon</span>(<span class="number">1</span>);<span class="built_in">make_runs</span>();</span><br><span class="line">        <span class="built_in">sort</span>(per+<span class="number">1</span>,per+pt+<span class="number">1</span>);<span class="built_in">reverse</span>(per+<span class="number">1</span>,per+pt+<span class="number">1</span>);</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=pt;i++)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span> || per[i].fi!=per[i<span class="number">-1</span>].fi) res+=<span class="number">1ll</span>*per[i].se*(per[i].se<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        ans-=res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    PAM::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) g[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ap[i]=PAM::<span class="built_in">insert</span>(ap[i<span class="number">-1</span>],i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) bp[i]=PAM::<span class="built_in">find_r</span>(bp[i+<span class="number">1</span>],i);</span><br><span class="line">    PAM::<span class="built_in">upd_fa</span>();</span><br><span class="line">    fa[<span class="number">1</span>]=<span class="number">0</span>;len[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot;i++) g[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ap[i]=<span class="built_in">max</span>(ap[i],<span class="number">1</span>),bp[i]=<span class="built_in">max</span>(bp[i],<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init_f</span>(tot);ST::<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) q[bp[i]].<span class="built_in">push_back</span>(ap[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>),<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    runs::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>加密</title>
    <url>/2021/01/01/%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><span id="more"></span>
<style>

.underline-input {
  border: none;
  border-bottom: #099 groove 1px;
  outline: none;
  transition-delay: 0s;
  transition-duration: 0.25s;
  transition-timing-function: ease-in-out;
}

.underline-input:focus-visible {
  border-bottom: #0cc groove 1px;
  transition-delay: 0s;
  transition-duration: 0.25s;
  transition-timing-function: ease-in-out;
}

.gradual-button {
  padding: 0.5em 1em;
  text-align: center;
  border-radius: 0px;
  border-width: 0px;
  background-color: #ddd;
  transition-delay: 0s;
  transition-duration: 0.25s;
  transition-timing-function: ease-in-out;
}

.gradual-button:hover {
  cursor: pointer;
  background-color: #bbb;
  transition-delay: 0s;
  transition-duration: 0.25s;
  transition-timing-function: ease-in-out;
}
</style>
<script src="https://cdn.bootcss.com/crypto-js/3.1.9-1/crypto-js.min.js"></script>
<script>
    //DES加密
    function encryptByDES(message, key){
        var keyHex = CryptoJS.enc.Utf8.parse(key);
        var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
        });
        return encrypted.ciphertext.toString();
    }
    //DES加密
    function decryptByDES(ciphertext, key){
        var keyHex = CryptoJS.enc.Utf8.parse(key);
        var decrypted = CryptoJS.DES.decrypt({
            ciphertext: CryptoJS.enc.Hex.parse(ciphertext)
        }, keyHex, {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
        });
        var result_value = decrypted.toString(CryptoJS.enc.Utf8);
        return result_value;
    }
    function loadMath() {
        if (typeof MathJax === 'undefined') {
            window.MathJax = {
            loader: {
                load: ['[tex]/mhchem'],
                source: {
                '[tex]/amsCd': '[tex]/amscd',
                '[tex]/AMScd': '[tex]/amscd'
                }
            },
            tex: {
                inlineMath: {'[+]': [['$', '$']]},
                packages: {'[+]': ['mhchem']},
                tags: 'ams'
            },
            options: {
                renderActions: {
                findScript: [10, doc => {
                    document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                    const display = !!node.type.match(/; *mode=display/);
                    const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                    const text = document.createTextNode('');
                    node.parentNode.replaceChild(text, node);
                    math.start = {node: text, delim: '', n: 0};
                    math.end = {node: text, delim: '', n: 0};
                    doc.math.push(math);
                    });
                }, '', false],
                insertedScript: [200, () => {
                    document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                        target.parentNode.classList.add('has-jax');
                    }
                    });
                }, '', false]
                }
            }
            };
            (function () {
            var script = document.createElement('script');
            script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
            script.defer = true;
            document.head.appendChild(script);
            })();
        } else {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
        }
    }
    function encrypt(demo,str1,key1) {
        var s , key , text;
        s = document.getElementById(str1).value;
        key = document.getElementById(key1).value;
        text = encryptByDES(s, key);
        document.getElementById(demo).innerHTML = text;
    }
    function decrypt(demo,str1,key1) {
        var s , key , text;
        s = document.getElementById(str1).value;
        key = document.getElementById(key1).value;
        text = decryptByDES(s, key);
        document.getElementById(demo).innerHTML = text;
        loadMath();
    }
</script>

<h2 id="DES-加密"><a href="#DES-加密" class="headerlink" title="DES 加密"></a>DES 加密</h2><p>文本：</p>
<input id="str1">

<p>秘钥：</p>
<input type="password" id="key1">

<p>加密文本：<p id="demo1"></p></p>
<p><button type="button" onclick="encrypt('demo1','str1','key1')">加密</button></p>
<h2 id="DES-解密"><a href="#DES-解密" class="headerlink" title="DES 解密"></a>DES 解密</h2><p>文本：</p>
<input id="str2">

<p>秘钥：</p>
<input type="password" id="key2">

<p>解密文本：<p id="demo2"></p></p>
<p><button type="button" onclick="decrypt('demo2','str2','key2')">加密</button></p>
]]></content>
      <tags>
        <tag>test</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地求区间本质不同回文串</title>
    <url>/2021/10/17/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%B1%82%E5%8C%BA%E9%97%B4%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>如何优雅地求区间本质不同回文串</p>
<span id="more"></span>

<h2 id="0-O-n-2"><a href="#0-O-n-2" class="headerlink" title="0. $O(n^2)$"></a>0. $O(n^2)$</h2><p>直接暴力。一点都不优雅。</p>
<h2 id="1-O-n-sqrt-n-Sigma"><a href="#1-O-n-sqrt-n-Sigma" class="headerlink" title="1. $O(n\sqrt n\Sigma)$"></a>1. $O(n\sqrt n\Sigma)$</h2><p>允许双向加的回文树，再套一个(在线)莫队即可。</p>
<p>太拉了，还难写。</p>
<h2 id="2-O-n-log-2-n"><a href="#2-O-n-log-2-n" class="headerlink" title="2. $O(n\log^2 n)$"></a>2. $O(n\log^2 n)$</h2><p>考虑离线，依次加入字符，维护每个 $i$ 作为左端点的答案。</p>
<p>考虑维护差分数组，这样每次答案是一段后缀和。</p>
<p>思考一种暴力思路：在回文树上，对于每个串 $s_j$ 记录最晚出现位置 $p_j$。</p>
<p>设一次加入后字符串长度为 $n$，本质上是对于回文树上这个字符串到根路径上所有字符串 $s_j$，在 $p_j$ 处 $-1$，在 $n-|s_j|$ 处 $+1$，并将 $p_j$ 改为 $n-|s_j|$。</p>
<p>直接做显然会被卡掉。</p>
<p>考虑一个事情，每个回文串的 border 可以表示为 $O(\log n)$ 个等差数列。注意到一个性质：对于回文串 $s$，如果存在长度 $q(q&gt;\frac{|s|}2)$ 的回文前缀，那么一定存在 $|s|-q$ 的周期。换句话说，如果存在长度为 $p,q(p&gt;q&gt;\frac{|s|}{2})$ 的回文前缀，那么一定存在 $2q-p$ 是回文前缀。</p>
<p>所以任意两个等差数列都有前者的首项大于后者的末项的两倍。</p>
<p>并且观察到一个事实：对于等差数列 $s_i=u^i+s_0$，一定有 $p_i=-i|u|+p_0$。换句话说这个字符串的贡献是当前左端点到后一项的左端点。</p>
<p><img src="/image/1.png"></p>
<p>贡献和的并就是最后一个位置为右端点，整个区间上一次出现位置为左端点的区间。</p>
<p>换句话说，我们只需要贡献所有不存在长度 $&gt;\frac{|s|}2$ 的回文串后缀的后缀 $s$ 即可。这样的 $s$ 最多 $O(\log n)$ 个，具体求出可以直接在回文树上预处理。</p>
<p>复杂度 $O(n\log^2 n)$。</p>
<h2 id="3-O-n-log-n"><a href="#3-O-n-log-n" class="headerlink" title="3. $O(n\log n)$"></a>3. $O(n\log n)$</h2><p>对于任意字符串 $s$，如果 $s$ 不是整循环串，那么 $s$ 的所有循环位移中至多只有 $2$ 个是回文串。可以想象一个定义在圆上的函数，如果有两条不重合的对称轴，那么一定是一个周期函数。</p>
<p>考虑原串的 Runs $(l,r,p)$，显然 $s[l:l+p-1]$ 不是整循环串（Runs 的定义），那么至多只有 $2$ 个<strong>极长整循环周期为 $p$</strong> 的回文串。</p>
<p>可以发现上述算法中，每个<strong>极长整循环</strong>的回文串只有在循环节处会产生 $O(\log n)$ 的处理代价。而所有极长整循环的回文串指数之和不超过 Runs 的指数之和的两倍，故是 $O(n)$ 的。</p>
<p>所以上面那个算法其实是 $O(n\log n)$ 的。</p>
]]></content>
      <tags>
        <tag>idea</tag>
        <tag>字符串</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Canadian Computing Olympiad 2020</title>
    <url>/2021/11/16/CCO2020/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://loj.ac/p?tagIds=246,274">链接</a></h2><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{gray}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{gray}{\texttt{-}}$</td>
<td align="center">$\color{green}{\texttt{+6}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{red}{\texttt{+3}}$</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="A-A-Game-with-Grundy"><a href="#A-A-Game-with-Grundy" class="headerlink" title="A. A Game with Grundy"></a>A. A Game with Grundy</h2><p>直接把每个朋友的视野在 $y=Y$ 上截得的整点区间求出，然后离散化之后扫一遍即可。</p>
<h2 id="B-Exercise-Deadlines"><a href="#B-Exercise-Deadlines" class="headerlink" title="B. Exercise Deadlines"></a>B. Exercise Deadlines</h2><p>题目可以转化成：构造一个排列，满足 $p_i\leq d_i$，要求 $p_i$ 逆序对个数尽可能少。</p>
<p>直接贪心，从后往前贪心取没有被取的数且 $\leq d_i$ 中最大的。容易证明取更小的会使逆序对个数增加，并且更不容易合法。</p>
<p>最后再求一遍逆序对个数，复杂度 $O(n\log n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> f[N],d[N];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">int</span> a[N],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">for</span>(;x;x-=x&amp;-x) a[x]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> v=<span class="number">0</span>;<span class="keyword">for</span>(;x&lt;=n;x+=x&amp;-x) v+=a[x];<span class="keyword">return</span> v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p=s.<span class="built_in">upper_bound</span>(d[i]);</span><br><span class="line">        <span class="keyword">if</span>(p==s.<span class="built_in">begin</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        f[i]=*--p,s.<span class="built_in">erase</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=<span class="built_in">qry</span>(f[i]),<span class="built_in">add</span>(f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="C-Mountains-and-Valleys"><a href="#C-Mountains-and-Valleys" class="headerlink" title="C. Mountains and Valleys"></a>C. Mountains and Valleys</h2><p>如果没有非树边，答案是两倍边数减去直径边数。</p>
<p>结论：至多只会选一条非树边。这个比较好证，因为如果选了两条，答案至少为 $\frac{5n}{3}$，然而此时直径长度有 $\frac{n}{3}$，所以不如直接跑原树</p>
<p>加上树边之后的策略是：断掉对应路径上的一条树边，最大化直径。</p>
<p>分类讨论直径与环的关系<del>即可</del>。</p>
<h2 id="D-Travelling-Salesperson"><a href="#D-Travelling-Salesperson" class="headerlink" title="D. Travelling Salesperson"></a>D. Travelling Salesperson</h2><p>挺妙的题。结论是：以任意点出发的最短路径合法长度都是 $n$。</p>
<p>考虑用增量法构造。假设当前有一条合法路径，要插入点 $u$，如果当前路径全部同色，那么直接将 $u$ 插入末尾一定合法。否则假设路径异色的分界点为 $v$，其前驱为 $v_L$ 后继为 $v_R$，如果 $(u,v_L)$ 与 $(u,v)$ 同色，那么直接将 $u$ 插入 $v_L$ 与 $v$ 直接，如果 $(u,v)$ 与 $(u,v_R)$ 同色那么插入 $v$ 与 $v_R$ 之间。如果都不满足那么 $(u,v_L),(u,v_R)$ 与 $(v_L,v),(v_R,v)$ 中的至少一条同色， 插入另一条边即可。</p>
<p><del>构造就是对结论的证明</del>。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> L[N],R[N];</span><br><span class="line"><span class="keyword">bool</span> g[N][N];<span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;L[R[x]]=y;L[y]=x;R[y]=R[x];R[x]=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) <span class="keyword">if</span>(s[j]==<span class="string">&#x27;R&#x27;</span>) g[i][j]=g[j][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i%n+<span class="number">1</span>,t=j;<span class="keyword">bool</span> hv=<span class="literal">true</span>;</span><br><span class="line">        R[i]=j,R[j]=<span class="number">0</span>,L[i]=<span class="number">0</span>,L[j]=i;</span><br><span class="line">        <span class="keyword">for</span>(j=j%n+<span class="number">1</span>;j!=i;j=j%n+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!R[t])&#123;<span class="built_in">ins</span>(t,j);<span class="keyword">if</span>(g[t][j]!=g[L[t]][t]) hv=<span class="literal">false</span>;<span class="keyword">else</span> t=j;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[L[t]][j]==g[t][j] || g[t][j]==g[t][R[t]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ins</span>(L[t],j);</span><br><span class="line">                <span class="keyword">while</span>(t!=i &amp;&amp; g[L[t]][t]==g[t][R[t]]) t=L[t];</span><br><span class="line">                <span class="keyword">if</span>(t==i) <span class="keyword">while</span>(R[t]) t=R[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="built_in">ins</span>(t,j);<span class="keyword">while</span>(R[t] &amp;&amp; g[L[t]][t]==g[t][R[t]]) t=R[t];&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=i;u;u=R[u]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="E-Interval-Collection"><a href="#E-Interval-Collection" class="headerlink" title="E. Interval Collection"></a>E. Interval Collection</h2><p>首先容易证明，最优集合中一定只有至多两个区间。</p>
<p>分类讨论:</p>
<ul>
<li>如果不存在无交区间，那么最小的交一定是 $r$ 最小的区间与 $l$ 最大的区间。<br>  当然 $r$ 相同的区间可能有很多，根据题目要求选最大的即可。$l$ 同理。这部分可以用 <code>multiset</code> 解决。</li>
<li>如果存在区间无交，不妨枚举分界点 $p$，相当于在 $p$ 左边找一个左端点最大的，右边找一个左端点最小的。<br>  如果每次取当前需要处理的区间 $[l,r]$ 的中点 $\text{mid}$，那么本质上是问右端点在 $[l,mid]$ 的区间中左端点最小值，$[ mid+1,r]$ 同理。可以发现这就是线段树的过程，直接用线段树维护即可。</li>
</ul>
<p>复杂度 $O(n\log n)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>,mx=<span class="number">1000000</span>,inf=<span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(multiset&lt;<span class="keyword">int</span>&gt;&amp;x)</span></span>&#123;<span class="keyword">return</span> x.<span class="built_in">empty</span>()?-inf:*x.<span class="built_in">rbegin</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(multiset&lt;<span class="keyword">int</span>&gt;&amp;x)</span></span>&#123;<span class="keyword">return</span> x.<span class="built_in">empty</span>()?inf:*x.<span class="built_in">begin</span>();&#125;</span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt;sl[N],sr[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,s;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> l=-inf,<span class="keyword">int</span> r=inf):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">s</span>(r-l)&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> s):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">node <span class="keyword">operator</span> +(node a,node b)&#123;<span class="keyword">return</span> <span class="built_in">node</span>(<span class="built_in">max</span>(a.l,b.l),<span class="built_in">min</span>(a.r,b.r),<span class="built_in">min</span>(&#123;a.s,b.s,b.r-a.l&#125;));&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> u=<span class="number">1</span>,<span class="keyword">int</span> l=<span class="number">1</span>,<span class="keyword">int</span> r=mx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[u]=<span class="built_in">node</span>(<span class="built_in">max</span>(sl[l]),<span class="built_in">min</span>(sr[l]));<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=mid) <span class="built_in">update</span>(p,u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(p,u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    t[u]=t[u&lt;&lt;<span class="number">1</span>]+t[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(multiset&lt;<span class="keyword">int</span>&gt;&amp;x,<span class="keyword">int</span> y)</span></span>&#123;x.<span class="built_in">erase</span>(x.<span class="built_in">find</span>(y));&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;L,R;</span><br><span class="line">    <span class="keyword">while</span>(q --&gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">3</span>];<span class="keyword">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) L.<span class="built_in">insert</span>(l),R.<span class="built_in">insert</span>(r),sl[r].<span class="built_in">insert</span>(l),sr[l].<span class="built_in">insert</span>(r);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">erase</span>(L,l),<span class="built_in">erase</span>(R,r),<span class="built_in">erase</span>(sl[r],l),<span class="built_in">erase</span>(sr[l],r);</span><br><span class="line">        <span class="built_in">update</span>(l),<span class="built_in">update</span>(r);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>(L)&lt;<span class="built_in">min</span>(R)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(sr[<span class="built_in">max</span>(L)])-<span class="built_in">max</span>(sl[<span class="built_in">min</span>(R)]));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t[<span class="number">1</span>].s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="F-Shopping-Plans"><a href="#F-Shopping-Plans" class="headerlink" title="F. Shopping Plans"></a>F. Shopping Plans</h2><p>牛逼题。</p>
<p>首先当然组内排序。考虑先处理 $x_j=y_j=1$ 的部分，也就是说每个组只会选择一个数字。</p>
<p>一种很显然的做法是：维护每个序列指针和一个位置 $p$ 表示当前已经处理到 $p$ 对应组。每次从队列中取出最小值，将 $p$ 对应组往后移一位，或者选择一个 $p’&gt;p$ 后移一维，容易证明是不重不漏的。复杂度 $O(n^2\log n)$。</p>
<p>可以发现这样非常浪费，因为每次都要枚举 $p’$，决策数量 $O(n)$。思考能不能一次只移动 $p’\leftarrow p+1$。</p>
<p>但是直接做是不行的，因为如果我们只让 $p’=p+1$，那么新状态实际上和原先相同。如果钦定 $p’$ 对应组移动一步，然而每一组不一定强制移动。</p>
<p>考虑增加一个“反悔”机制，即：如果 $p’=p+1$ 然而 $p$ 对应组只移动了恰好一步，我们可以认为这一步是为了转移“被迫的”，在令 $p’$ 移动一步的同时撤销 $p$ 的移动。</p>
<p>不过这样要求对于 $p’&gt;p$，$p’$ 移动第一步一定要比 $p$ 移动第一步要优，因为我们无法在 $p$ 移动第一步之前将 $p’$ 放入堆。所以开始时将组按 $a_2-a_1$ 从小到大排序即可。复杂度 $O(k\log k)$。</p>
<p>考虑 $m=1$ 的部分，即需要对组内处理。首先枚举所有可行长度 $L\in[x_i,y_i]$，将前 $L$ 个字符加入初始队列。<br>队列中维护 $l,r,p$，表示当前在修改 $p$，其中 $p$ 从 $l$ 位置开始，不能超过 $r$。每次操作可以：将 $p$ 后移一位，或者将 $l$ 设置为 $l-1$，同时 <code>r=p , p=l-1</code>。这样每次只有两种决策，复杂度 $O(k\log k)$。</p>
<p>最后对于正解，将每个组当成一个黑箱子，可以发现黑箱子中的操作只有输出下一个的解，这恰好就是 $m=1$ 时求的东西，直接两层 $k$ 短路即可。复杂度 $O(k\log k)$。</p>
<details>
    <summary>代码</summary>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 100000000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(x) ((int)x.size())</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;f[N];<span class="keyword">int</span> l[N],r[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sta</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,p;ll s;</span><br><span class="line">    <span class="built_in">sta</span>(<span class="keyword">int</span> l=<span class="number">0</span>,<span class="keyword">int</span> r=<span class="number">0</span>,<span class="keyword">int</span> p=<span class="number">0</span>,ll s=<span class="number">0</span>):<span class="built_in">l</span>(l),<span class="built_in">r</span>(r),<span class="built_in">p</span>(p),<span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> sta a)<span class="keyword">const</span>&#123;<span class="keyword">return</span> s&gt;a.s;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    priority_queue&lt;sta&gt;q;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        h.<span class="built_in">swap</span>(f[u]);</span><br><span class="line">        ll s=<span class="number">0</span>;r[u]=<span class="built_in">min</span>(r[u],<span class="built_in">S</span>(h));</span><br><span class="line">        <span class="keyword">if</span>(l[u]==<span class="number">0</span>) q.<span class="built_in">push</span>(<span class="built_in">sta</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r[u];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s+=h[i];</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=l[u]) q.<span class="built_in">emplace</span>(i,<span class="built_in">S</span>(h),i,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt;res;</span><br><span class="line">    ll <span class="keyword">operator</span> [](<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="built_in">S</span>(res))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; x&gt;=<span class="built_in">S</span>(res))</span><br><span class="line">            &#123;</span><br><span class="line">                sta u=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(u.s);</span><br><span class="line">                <span class="keyword">if</span>(u.p+<span class="number">1</span>&lt;u.r) q.<span class="built_in">emplace</span>(u.l,u.r,u.p+<span class="number">1</span>,u.s+h[u.p+<span class="number">1</span>]-h[u.p]);</span><br><span class="line">                <span class="keyword">if</span>(u.p!=u.l &amp;&amp; u.l&gt;<span class="number">0</span>) q.<span class="built_in">emplace</span>(u.l<span class="number">-1</span>,u.p,u.l,u.s+h[u.l]-h[u.l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="built_in">S</span>(res)) <span class="keyword">return</span> inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;g[N];</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sta2</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p,x;ll s;</span><br><span class="line">    <span class="built_in">sta2</span>(<span class="keyword">int</span> p=<span class="number">0</span>,<span class="keyword">int</span> x=<span class="number">0</span>,ll s=<span class="number">0</span>):<span class="built_in">p</span>(p),<span class="built_in">x</span>(x),<span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> sta2 a)<span class="keyword">const</span>&#123;<span class="keyword">return</span> s&gt;a.s;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;sta2&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),f[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l[i],&amp;r[i]),<span class="built_in">sort</span>(f[i].<span class="built_in">begin</span>(),f[i].<span class="built_in">end</span>()),g[i].<span class="built_in">init</span>(i),id[i]=i;</span><br><span class="line">    cerr&lt;&lt;<span class="string">&quot;start&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">1</span>,id+m+<span class="number">1</span>,[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;<span class="keyword">return</span> g[x][<span class="number">1</span>]-g[x][<span class="number">0</span>]&lt;g[y][<span class="number">1</span>]-g[y][<span class="number">0</span>];&#125;);</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) s+=g[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=inf)&#123;<span class="keyword">while</span>(k --&gt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,s);k--;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">1</span>,s+g[id[<span class="number">1</span>]][<span class="number">1</span>]-g[id[<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span>(k --&gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sta2 u=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();<span class="keyword">int</span> i=id[u.p],j=id[u.p+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(u.s&gt;=inf)&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">while</span>(k --&gt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,u.s);</span><br><span class="line">        q.<span class="built_in">emplace</span>(u.p,u.x+<span class="number">1</span>,u.s+g[i][u.x+<span class="number">1</span>]-g[i][u.x]);</span><br><span class="line">        <span class="keyword">if</span>(u.p&lt;m) q.<span class="built_in">emplace</span>(u.p+<span class="number">1</span>,<span class="number">1</span>,u.s+g[j][<span class="number">1</span>]-g[j][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(u.p&lt;m &amp;&amp; u.x==<span class="number">1</span>) q.<span class="built_in">emplace</span>(u.p+<span class="number">1</span>,<span class="number">1</span>,u.s+g[j][<span class="number">1</span>]-g[j][<span class="number">0</span>]-(g[i][<span class="number">1</span>]-g[i][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>CCO</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-2016 Petrozavodsk Winter Training Camp, Saratov SU Contest</title>
    <url>/2021/11/16/gym100886/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://codeforces.com/gym/100886">链接</a></h2><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\color{green}{\texttt{+5}}$</td>
<td align="center">$\color{red}{\texttt{+1}}$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">$\color{green}{\texttt{+4}}$</td>
<td align="center">$\color{green}{\texttt{+1}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{green}{\texttt{+}}$</td>
<td align="center">$\color{red}{\texttt{+}}$</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="G-Maximum-Product"><a href="#G-Maximum-Product" class="headerlink" title="G. Maximum Product"></a>G. Maximum Product</h2><p>签到题。<del>然而贡献了 <strong>4</strong> 发罚时</del>。</p>
<h2 id="J-Sockets"><a href="#J-Sockets" class="headerlink" title="J. Sockets"></a>J. Sockets</h2><p>考虑贪心，显然会选要求最低（深度最深）的若干个设备，同时插线板一定是越多口放越上面。</p>
<p>考虑二分答案，变成判定性问题。因为确定了深度最浅的设备，而插线板一定是能插就插不会更列，所以将当层设备插入之后剩下的口先贪心插接线板，如果没有了再插剩下的电器。</p>
<p>复杂度 $O(n\log n)$。</p>
<h2 id="H-Biathlon-2-0"><a href="#H-Biathlon-2-0" class="headerlink" title="H. Biathlon 2.0"></a>H. Biathlon 2.0</h2><p>简化后题意就是给一个点集，问点 $(x,y)$ 与点集内点点积最小值。</p>
<p>直接建下凸包然后二分即可。复杂度 $O(n\log n)$。</p>
<h2 id="A-Three-Servers"><a href="#A-Three-Servers" class="headerlink" title="A. Three Servers"></a>A. Three Servers</h2><p>赛时乱搞过了。考虑维护集合 $A,B$ 与 $B,C$ 的差值，直接 dp，可以做到 $O(n^3t^2)$，过不去。</p>
<p>考虑其实权值大于 $t^2$ 没有存的必要了。只取绝对值 $\leq t^2$ 的部分，复杂度 $O(nt^4)$。稍微卡卡常能过？</p>
<p>赛时直接取 $V=200$，然后 <code>random_shuffle</code> 过了。。。</p>
<h2 id="I-Archaeological-Research"><a href="#I-Archaeological-Research" class="headerlink" title="I. Archaeological Research"></a>I. Archaeological Research</h2><p>如果 $i$ 存在一个后继是 $j$，事实上的限制只有 $a[i+1,j-1]$ 区间所有数与 $a_j$ 不同。</p>
<p>换句话说对于每个 $j$ 找到最小限制的 $l$，那么 $a_j=\operatorname{mex}_{k\in(l,j)}{a_k}$。</p>
<p>直接值域线段树。复杂度 $O(n\log n)$。</p>
<h2 id="K-Toll-Roads"><a href="#K-Toll-Roads" class="headerlink" title="K. Toll Roads"></a>K. Toll Roads</h2><p>先枚举免费的路径的一个端点，考虑 dfs 过程中枚举另一个端点 $u$ 统计答案。可以发现直径只有：</p>
<ul>
<li>$u$ 子树内的最长链。</li>
<li>$u$ 子树外且一端为 $u$ 到根路径上的最长链加上 $u$ 子树内，一端为 $u$ 的最长链。</li>
<li>$u$ 子树外选两条外挂的链。</li>
</ul>
<p><img src="/image/8.png" alt="image"></p>
<p>首先 dfs 一遍求出 $u$ 为根子树内最长链与一端为 $u$ 的最长链。</p>
<p>然后再 dfs 一遍，过程中传入一个点到根路径上的最长链与次长链。处理过程中可能会需要记录前三大值。最后分讨一下可以得到以 $u$ 为免费路径端点时的直径。</p>
<p>复杂度 $O(n^2)$。</p>
<h2 id="B-Game-on-Bipartite-Graph"><a href="#B-Game-on-Bipartite-Graph" class="headerlink" title="B. Game on Bipartite Graph"></a>B. Game on Bipartite Graph</h2><p>假设右边第 $i$ 个点权值为 $2^i$，左边每个点权值 $v_i$ 为所有连出的边对应点权值异或和。</p>
<p>结论：以 $s$ 为当前点的游戏是先手必胜的当且仅当 $v_s$ 不能被 ${v_i},i\neq s$ 异或表示。</p>
<details>
    <summary>证明</summary>

<p>构造 01 矩阵 $A$，$A_{i,j}=1$ 当且仅当左边的 $i$ 与右边的 $j$ 有边。</p>
<p>容易发现，结论转化为以 $s$ 为起点是先手必胜当且仅当 $A$ 的秩不等于 $A$ 删去第 $s$ 行的秩。</p>
<p>由于是平等博弈，所以先手移动到 $t$ 后是后手必败当且仅当 $A^T$ 删去第 $t$ 行后秩不发生变化。</p>
<p>由于 $A^T$ 的秩等于 $A$ 的秩，所以命题等价于：对于任意列 $s$，如果删去 $s$ 后秩变化，那么一定存在一个位置 $A_{s,i}=1$，满足将 $A_{s,i}$ 置 $0$ 后的秩等于删去第 $i$ 行后的秩。</p>
<p>因为删去 $s$ 后秩变化，所以 $s$ 必然存在一个主元行。容易证明将某个主元列的 $1$ 置 $0$ 后的秩等于删去该行后的秩。故命题得证。</p>
</details>

<p>然后直接暴力枚举哪一步可以使对方必败即可。</p>
]]></content>
      <tags>
        <tag>Virtual participation</tag>
        <tag>gym</tag>
      </tags>
  </entry>
</search>
